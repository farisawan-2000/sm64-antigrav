diff --git a/Makefile b/Makefile
index 2c7ca6c..70e9f86 100644
--- a/Makefile
+++ b/Makefile
@@ -366,6 +366,9 @@ asm/boot.s: $(BUILD_DIR)/lib/bin/ipl3_font.bin
 
 $(BUILD_DIR)/lib/bin/ipl3_font.bin: lib/ipl3_font.png
 	$(IPLFONTUTIL) e $< $@
+	
+#Required so the compiler doesn't complain about this not existing.
+$(BUILD_DIR)/src/game/camera.o: $(BUILD_DIR)/include/text_strings.h
 
 $(BUILD_DIR)/include/text_strings.h: include/text_strings.h.in
 	$(TEXTCONV) charmap.txt $< $@
diff --git a/enhancements/bettercamera.h b/enhancements/bettercamera.h
new file mode 100644
index 0000000..c1137b7
--- /dev/null
+++ b/enhancements/bettercamera.h
@@ -0,0 +1,26 @@
+#define NC_MODE_NORMAL            0x0
+#define NC_MODE_FIXED             0x1
+#define NC_MODE_2D                0x2
+#define NC_MODE_8D                0x3
+#define NC_MODE_FIXED_NOMOVE      0x4
+#define NC_MODE_NOTURN            0x5
+
+
+extern void newcam_display_options();
+extern void newcam_check_pause_buttons();
+
+extern u8 newcam_option_open;
+
+extern u8 newcam_sensitivityX; //How quick the camera works.
+extern u8 newcam_sensitivityY;
+extern u8 newcam_invertX;
+extern u8 newcam_invertY;
+extern u8 newcam_panlevel; //How much the camera sticks out a bit in the direction you're looking.
+extern u8 newcam_aggression; //How much the camera tries to centre itself to Mario's facing and movement.
+extern u8 newcam_active; // basically the thing that governs if newcam is on.
+extern u16 sSoundMode;
+extern u8 newcam_analogue;
+extern u8 newcam_intendedmode;
+
+extern u8 newcam_mode;
+extern s16 newcam_yaw;
diff --git a/enhancements/bettercamera.inc.c b/enhancements/bettercamera.inc.c
new file mode 100644
index 0000000..0631701
--- /dev/null
+++ b/enhancements/bettercamera.inc.c
@@ -0,0 +1,985 @@
+#include "sm64.h"
+#include "game/camera.h"
+#include "game/level_update.h"
+#include "game/print.h"
+#include "engine/math_util.h"
+#include "game/segment2.h"
+#include "game/save_file.h"
+#include "bettercamera.h"
+#include "include/text_strings.h"
+
+
+
+/**
+Quick explanation of the camera modes
+
+NC_MODE_NORMAL: Standard mode, allows dualaxial movement and free control of the camera.
+NC_MODE_FIXED: Disables control of camera, and the actual position of the camera doesn't update.
+NC_MODE_2D: Disables horizontal control of the camera and locks Mario's direction to the X axis. NYI though.
+NC_MODE_8D: 8 directional movement. Similar to standard, except the camera direction snaps to 8 directions.
+NC_MODE_FIXED_NOMOVE: Disables control and movement of the camera.
+NC_MODE_NOTURN: Disables horizontal and vertical control of the camera.
+**/
+
+//!A bunch of developer intended options, to cover every base, really.
+//#define NEWCAM_DEBUG //Some print values for puppycam. Not useful anymore, but never hurts to keep em around.
+#define nodelta //I designed puppycam with deltatime in mind, rather than outright remove it, I'll just define a value.
+//#define nosound //If for some reason you hate the concept of audio, you can disable it.
+//#define noaccel //Disables smooth movement of the camera with the C buttons.
+#define precision 32.0f //How many steps the ray takes. You should leave it at 24.
+#define degrade 0.1f //What percent of the remaining camera movement is degraded. Default is 10%
+
+
+//!Hardcoded camera angle stuff. They're essentially area boxes that when Mario is inside, will trigger some view changes.
+struct newcam_hardpos
+{
+    u8 newcam_hard_levelID;
+    u8 newcam_hard_areaID;
+    u8 newcam_hard_permaswap;
+    u8 newcam_hard_modeset;
+    s16 newcam_hard_X1;
+    s16 newcam_hard_Y1;
+    s16 newcam_hard_Z1;
+    s16 newcam_hard_X2;
+    s16 newcam_hard_Y2;
+    s16 newcam_hard_Z2;
+    s16 newcam_hard_camX;
+    s16 newcam_hard_camY;
+    s16 newcam_hard_camZ;
+    s16 newcam_hard_lookX;
+    s16 newcam_hard_lookY;
+    s16 newcam_hard_lookZ;
+};
+
+//Permaswap is a boolean that simply determines wether or not when the camera changes at this point it stays changed. 0 means it resets when you leave, and 1 means it stays changed.
+//The camera position fields accept "32767" as an ignore flag.
+struct newcam_hardpos newcam_fixedcam[] =
+{
+{/*Level ID*/ 16,/*Area ID*/ 1,/*Permaswap*/ 0,/*Mode*/ NC_MODE_FIXED_NOMOVE, //Standard params.
+/*X begin*/ -540,/*Y begin*/ 800,/*Z begin*/ -3500, //Where the activation box begins
+/*X end*/ 540,/*Y end*/ 2000,/*Z end*/ -1500, //Where the activation box ends.
+/*Cam X*/ 0,/*Cam Y*/ 1500,/*Cam Z*/ -1000, //The position the camera gets placed for NC_MODE_FIXED and NC_MODE_FIXED_NOMOVE
+/*Look X*/ 0,/*Look Y*/ 800,/*Look Z*/ -2500} //The position the camera looks at for NC_MODE_FIXED_NOMOVE
+};
+
+#ifdef nodelta
+    u8 gDelta = 1;
+#endif // nodelta
+
+#ifdef noaccel
+    u8 accel = 100;
+    #else
+    u8 accel = 10;
+#endif // noaccel
+
+s16 newcam_yaw; //Z axis rotation
+s8 newcam_yaw_acc;
+s16 newcam_tilt = 1500; //Y axis rotation
+s8 newcam_tilt_acc;
+u16 newcam_distance = 750; //The distance the camera stays from the player
+u16 newcam_distance_target = 750; //The distance the player camera tries to reach.
+f32 newcam_pos_target[3]; //The position the camera is basing calculations off. *usually* Mario.
+f32 newcam_pos[3]; //Position the camera is in the world
+f32 newcam_lookat[3]; //Position the camera is looking at
+f32 newcam_framessincec[2];
+u8 newcam_centering = 0; // The flag that depicts wether the camera's goin gto try centering.
+s16 newcam_yaw_target; // The yaw value the camera tries to set itself to when the centre flag is active. Is set to Mario's face angle.
+f32 newcam_turnwait; // The amount of time to wait after landing before allowing the camera to turn again
+f32 newcam_pan_x;
+f32 newcam_pan_z;
+u8 newcam_cstick_down = 0; //Just a value that triggers true when the player 2 stick is moved in 8 direction move to prevent holding it down.
+
+u8 newcam_sensitivityX = 75; //How quick the camera works.
+u8 newcam_sensitivityY = 75;
+u8 newcam_invertX = 0; //Reverses movement of the camera axis.
+u8 newcam_invertY = 0;
+u8 newcam_panlevel = 75; //How much the camera sticks out a bit in the direction you're looking.
+u8 newcam_aggression = 0; //How much the camera tries to centre itself to Mario's facing and movement.
+u8 newcam_analogue = 0; //Wether to accept inputs from a player 2 joystick, and then disables C button input.
+s16 newcam_distance_values[] = {750,1250,2000};
+u8 newcam_active = 1; // basically the thing that governs if newcam is on.
+u8 newcam_mode = 0; // 0 is standard, 1 is fixed and 2 is 2d.
+u8 newcam_intendedmode = 0; // which camera mode the camera's going to try to be in when not forced into another.
+
+u8 newcam_option_open = 0;
+s8 newcam_option_selection = 0;
+f32 newcam_option_timer = 0;
+u8 newcam_option_index = 0;
+u8 newcam_option_scroll = 0;
+u8 newcam_option_scroll_last = 0;
+u8 newcam_total = 7; //How many options there are in newcam_uptions.
+u16 sSoundMode;
+
+u8 newcam_options[][64] = {{NC_ANALOGUE}, {NC_CAMX}, {NC_CAMY}, {NC_INVERTX}, {NC_INVERTY}, {NC_CAMC}, {NC_CAMP}};
+u8 newcam_flags[][64] = {{NC_DISABLED}, {NC_ENABLED}};
+u8 newcam_strings[][64] = {{NC_BUTTON}, {NC_BUTTON2}, {NC_OPTION}, {NC_HIGHLIGHT}};
+
+void newcam_init(struct Camera *c, u8 dv)
+{
+    newcam_tilt = 1500;
+    newcam_distance_target = newcam_distance_values[dv];
+    newcam_yaw = -c->yaw+0x4000; //Mario and the camera's yaw have this offset between them.
+    newcam_mode = NC_MODE_NORMAL;
+
+    switch (gCurrLevelNum)
+    {
+        case LEVEL_BITDW: newcam_yaw = 0x4000; newcam_mode = NC_MODE_8D; newcam_tilt = 4000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_BITFS: newcam_yaw = 0x4000; newcam_mode = NC_MODE_8D; newcam_tilt = 4000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_BITS: newcam_yaw = 0x4000; newcam_mode = NC_MODE_8D; newcam_tilt = 4000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_WF: newcam_yaw = 0x4000; newcam_tilt = 2000; newcam_distance_target = newcam_distance_values[1]; break;
+        case LEVEL_RR: newcam_yaw = 0x6000; newcam_tilt = 2000; newcam_distance_target = newcam_distance_values[2]; break;
+        case LEVEL_CCM: newcam_yaw = -0x4000; newcam_tilt = 2000; newcam_distance_target = newcam_distance_values[1]; break;
+        case LEVEL_WDW: newcam_yaw = 0x2000; newcam_tilt = 3000; newcam_distance_target = newcam_distance_values[1]; break;
+    }
+
+    newcam_distance = newcam_distance_target;
+    newcam_intendedmode = newcam_mode;
+}
+
+/** Mathematic calculations. This stuffs so basic even *I* understand it lol
+Basically, it just returns a position based on angle */
+static lengthdir_x(f32 length, s16 dir)
+{
+    return (s16) (length * coss(dir));
+}
+static lengthdir_y(f32 length, s16 dir)
+{
+    return (s16) (length * sins(dir));
+}
+
+static void newcam_diagnostics(void)
+{
+    print_text_fmt_int(32,192,"Lv %d",gCurrLevelNum);
+    print_text_fmt_int(32,176,"Area %d",gCurrAreaIndex);
+    print_text_fmt_int(32,160,"X %d",gMarioState->pos[0]);
+    print_text_fmt_int(32,144,"Y %d",gMarioState->pos[1]);
+    print_text_fmt_int(32,128,"Z %d",gMarioState->pos[2]);
+    print_text_fmt_int(32,96,"TILT UP %d",newcam_tilt_acc);
+    print_text_fmt_int(32,80,"YAW UP %d",newcam_yaw_acc);
+    print_text_fmt_int(32,64,"YAW %d",newcam_yaw);
+    print_text_fmt_int(32,48,"TILT  %d",newcam_tilt);
+    print_text_fmt_int(32,32,"DISTANCE %d",newcam_distance);
+}
+
+static newcam_adjust_value(s16 var, s16 val)
+{
+    var += val;
+    if (var > 100)
+        var = 100;
+    if (var < -100)
+        var = -100;
+
+    return var;
+}
+
+static newcam_approach_float(f32 var, f32 val, f32 inc)
+{
+    if (var < val)
+        return min(var + inc, val);
+        else
+        return max(var - inc, val);
+}
+
+static newcam_approach_s16(s16 var, s16 val, s16 inc)
+{
+    if (var < val)
+        return max(var + inc, val);
+        else
+        return min(var - inc, val);
+}
+
+newcam_init_settings()
+{
+    if (save_check_firsttime())
+    {
+        save_file_get_setting();
+    }
+    else
+    {
+        newcam_active = 1;
+        newcam_sensitivityX = 75;
+        newcam_sensitivityY = 75;
+        newcam_aggression = 0;
+        newcam_panlevel = 75;
+        newcam_invertX = 0;
+        newcam_invertY = 0;
+        save_set_firsttime();
+    }
+}
+
+ivrt(u8 axis)
+{
+    if (axis == 0)
+    {
+        if (newcam_invertX == 0)
+            return 1;
+        else
+            return -1;
+    }
+    else
+    {
+        if (newcam_invertY == 0)
+            return 1;
+        else
+            return -1;
+    }
+}
+
+static void newcam_rotate_button(void)
+{
+    if (newcam_mode == NC_MODE_NORMAL) //Standard camera rotation input for buttons.
+    {
+        if ((gPlayer1Controller->buttonDown & L_CBUTTONS) && newcam_analogue == 0)
+            newcam_yaw_acc = newcam_adjust_value(newcam_yaw_acc,gDelta*accel);
+        else if ((gPlayer1Controller->buttonDown & R_CBUTTONS) && newcam_analogue == 0)
+            newcam_yaw_acc = newcam_adjust_value(newcam_yaw_acc,-gDelta*accel);
+        else
+            #ifdef noaccel
+            newcam_yaw_acc = 0;
+            #else
+            newcam_yaw_acc -= gDelta*(newcam_yaw_acc*(0.1));
+            #endif
+    }
+    else
+    if (newcam_mode == NC_MODE_8D) //8 directional camera rotation input for buttons.
+    {
+        if ((gPlayer1Controller->buttonPressed & L_CBUTTONS) && newcam_analogue == 0)
+        {
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+            newcam_yaw_target = newcam_yaw+0x2000;
+            newcam_centering = 1;
+        }
+        else
+        if ((gPlayer1Controller->buttonPressed & R_CBUTTONS) && newcam_analogue == 0)
+        {
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+            newcam_yaw_target = newcam_yaw-0x2000;
+            newcam_centering = 1;
+        }
+    }
+
+    if (gPlayer1Controller->buttonDown & U_CBUTTONS  && newcam_mode != NC_MODE_NOTURN && newcam_analogue == 0)
+        newcam_tilt_acc = newcam_adjust_value(newcam_tilt_acc,gDelta*accel);
+    else if (gPlayer1Controller->buttonDown & D_CBUTTONS  && newcam_mode != NC_MODE_NOTURN && newcam_analogue == 0)
+        newcam_tilt_acc = newcam_adjust_value(newcam_tilt_acc,gDelta*-accel);
+    else
+        #ifdef noaccel
+        newcam_tilt_acc = 0;
+        #else
+        newcam_tilt_acc -= gDelta*(newcam_tilt_acc*(0.1));
+        #endif
+
+    newcam_framessincec[0] += gDelta;
+    newcam_framessincec[1] += gDelta;
+    if ((gPlayer1Controller->buttonPressed & L_CBUTTONS) && newcam_mode == NC_MODE_NORMAL && newcam_analogue == 0)
+    {
+        if (newcam_framessincec[0] < 6)
+        {
+            newcam_yaw_target = newcam_yaw+0x3000;
+            newcam_centering = 1;
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+        }
+        newcam_framessincec[0] = 0;
+    }
+    if ((gPlayer1Controller->buttonPressed & R_CBUTTONS) && newcam_mode == NC_MODE_NORMAL && newcam_analogue == 0)
+    {
+        if (newcam_framessincec[1] < 6)
+            {
+            newcam_yaw_target = newcam_yaw-0x3000;
+            newcam_centering = 1;
+            #ifndef nosound
+            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+            #endif
+        }
+        newcam_framessincec[1] = 0;
+    }
+
+
+    if (newcam_analogue == 1) //There's not much point in keeping this behind a check, but it wouldn't hurt, just incase any 2player shenanigans ever happen, it makes it easy to disable.
+    { //The joystick values cap at 80, so divide by 8 to get the same net result at maximum turn as the button
+        if (ABS(gPlayer2Controller->rawStickX) > 20)
+        {
+            switch (newcam_mode)
+            {
+                case NC_MODE_NORMAL: newcam_yaw_acc = newcam_adjust_value(newcam_yaw_acc,gDelta*(-gPlayer2Controller->rawStickX/4)); break;
+                case NC_MODE_8D:
+                    {
+                        if (newcam_cstick_down == 0)
+                        {
+                            newcam_cstick_down = 1;
+                            newcam_centering = 1;
+                            #ifndef nosound
+                            play_sound(SOUND_MENU_CAMERA_ZOOM_IN, gDefaultSoundArgs);
+                            #endif
+                            if (gPlayer2Controller->rawStickX > 20)
+                                newcam_yaw_target = newcam_yaw + 0x2000;
+                            else
+                                newcam_yaw_target = newcam_yaw - 0x2000;
+                        }
+                        break;
+                    }
+            }
+        }
+        else
+        {
+            newcam_cstick_down = 0;
+            newcam_yaw_acc -= gDelta*(newcam_yaw_acc*(degrade));
+        }
+
+        if (ABS(gPlayer2Controller->rawStickY) > 20 && newcam_mode != NC_MODE_NOTURN)
+            newcam_tilt_acc = newcam_adjust_value(newcam_tilt_acc,gDelta*(-gPlayer2Controller->rawStickY/4));
+        else
+            newcam_tilt_acc -= gDelta*(newcam_tilt_acc*(degrade));
+    }
+}
+
+static void newcam_zoom_button(void)
+{
+    //Smoothly move the camera to the new spot.
+    if (newcam_distance > newcam_distance_target)
+    {
+        newcam_distance -= gDelta*250;
+        if (newcam_distance < newcam_distance_target)
+            newcam_distance = newcam_distance_target;
+    }
+    if (newcam_distance < newcam_distance_target)
+    {
+        newcam_distance += gDelta*250;
+        if (newcam_distance > newcam_distance_target)
+            newcam_distance = newcam_distance_target;
+    }
+
+    //When you press L and R together, set the flag for centering the camera. Afterwards, start setting the yaw to the Player's yaw at the time.
+    if (gPlayer1Controller->buttonDown & L_TRIG && gPlayer1Controller->buttonDown & R_TRIG && newcam_mode == NC_MODE_NORMAL)
+    {
+        newcam_yaw_target = -gMarioState->faceAngle[1]-0x4000;
+        newcam_centering = 1;
+    }
+    else //Each time the player presses R, but NOT L the camera zooms out more, until it hits the limit and resets back to close view.
+    if (gPlayer1Controller->buttonPressed & R_TRIG)
+    {
+        #ifndef nosound
+        play_sound(SOUND_MENU_CLICK_CHANGE_VIEW, gDefaultSoundArgs);
+        #endif
+
+        if (newcam_distance_target == newcam_distance_values[0])
+            newcam_distance_target = newcam_distance_values[1];
+        else
+        if (newcam_distance_target == newcam_distance_values[1])
+            newcam_distance_target = newcam_distance_values[2];
+        else
+            newcam_distance_target = newcam_distance_values[0];
+
+    }
+    if (newcam_centering == 1)
+    {
+        newcam_yaw = approach_s16_symmetric(newcam_yaw,newcam_yaw_target,gDelta*0x800);
+        if (newcam_yaw = newcam_yaw_target)
+            newcam_centering = 0;
+    }
+}
+
+static void newcam_update_values(void)
+{//For tilt, this just limits it so it doesn't go further than 90 degrees either way. 90 degrees is actually 16384, but can sometimes lead to issues, so I just leave it shy of 90.
+    u8 waterflag = 0;
+    newcam_yaw += gDelta*(ivrt(0)*(newcam_yaw_acc*(newcam_sensitivityX/10)));
+    if ((newcam_tilt < 12000 && newcam_tilt_acc*ivrt(1) > 0) || (newcam_tilt > -12000 && newcam_tilt_acc*ivrt(1) < 0))
+        newcam_tilt += gDelta*(ivrt(1)*(newcam_tilt_acc*(newcam_sensitivityY/10)));
+    else
+    {
+        if (newcam_tilt > 12000)
+            newcam_tilt = 12000;
+        if (newcam_tilt < -12000)
+            newcam_tilt = -12000;
+    }
+
+        if (newcam_turnwait > 0 && gMarioState->vel[1] == 0)
+        {
+            newcam_turnwait -= gDelta;
+            if (newcam_turnwait < 0)
+                newcam_turnwait = 0;
+        }
+        else
+        {
+        if (gMarioState->intendedMag > 0 && gMarioState->vel[1] == 0 && newcam_mode == NC_MODE_NORMAL)
+            newcam_yaw = (approach_s16_symmetric(newcam_yaw,-gMarioState->faceAngle[1]-0x4000,gDelta*((newcam_aggression*(ABS(gPlayer1Controller->rawStickX/10)))*(gMarioState->forwardVel/32))));
+        else
+            newcam_turnwait = 10;
+        }
+
+        switch (gMarioState->action)
+        {
+            case ACT_BUTT_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+            case ACT_STOMACH_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+            case ACT_HOLD_BUTT_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+            case ACT_HOLD_STOMACH_SLIDE: if (gMarioState->forwardVel > 8) waterflag = 1; break;
+
+            case ACT_SHOT_FROM_CANNON: waterflag = 1; break;
+            case ACT_FLYING: waterflag = 1; break;
+        }
+
+        if (gMarioState->action & ACT_FLAG_SWIMMING)
+        {
+            if (gMarioState->forwardVel > 2)
+            waterflag = 1;
+        }
+
+        if (newcam_mode != NC_MODE_NORMAL)
+            waterflag = 0;
+
+        if (waterflag == 1)
+        {
+            newcam_yaw = (approach_s16_symmetric(newcam_yaw,-gMarioState->faceAngle[1]-0x4000,gDelta*(gMarioState->forwardVel*128)));
+            if ((signed)gMarioState->forwardVel > 1)
+                newcam_tilt = (approach_s16_symmetric(newcam_tilt,(-gMarioState->faceAngle[0]*0.8)+3000,gDelta*(gMarioState->forwardVel*32)));
+            else
+                newcam_tilt = (approach_s16_symmetric(newcam_tilt,3000,gDelta*32));
+        }
+}
+
+static newcam_check_geocol(s16 xup, s16 yup, s16 zup)
+{
+    f32 ceilY, floorY;
+    struct Surface *surf;
+    f32 xup2;
+    f32 yup2;
+    f32 zup2;
+    s16 returnvar;
+
+    struct WallCollisionData wallC;
+    struct Surface *wall;
+
+    xup2 = xup;
+    yup2 = yup;
+    zup2 = zup;
+
+    wallC.x = xup2;
+    wallC.y = yup2;
+    wallC.z = zup2;
+    wallC.radius = 32.0f;
+    wallC.offsetY = 0.0f;
+
+    if (find_wall_collisions(&wallC) != 0)
+    {
+        wall = wallC.walls[wallC.numWalls - 1];
+        xup2 = wallC.x + 128.0f * wall->normal.x;
+        zup2 = wallC.z + 128.0f * wall->normal.z;
+    }
+
+    floorY = find_floor(xup2, yup2, zup2, &surf);
+    ceilY = find_ceil(xup2, yup2, zup2, &surf);
+
+    if ((-11000.f != floorY) && (20000.f == ceilY)) {
+        if (yup2 < (floorY += 64)) {
+            yup2 = floorY+64;
+        }
+    }
+
+    if ((-11000.f == floorY) && (20000.f != ceilY)) {
+        if (yup2 > (ceilY -= 64)) {
+            yup2 = ceilY-64;
+        }
+    }
+
+    if ((-11000.f != floorY) && (20000.f != ceilY)) {
+        floorY += 64;
+        ceilY -= 64;
+
+        if ((yup2 <= floorY) && (yup2 < ceilY)) {
+            yup2 = floorY+64;
+        }
+        if ((yup2 > floorY) && (yup2 >= ceilY)) {
+            yup2 = ceilY-64;
+        }
+        if ((yup2 <= floorY) && (yup2 >= ceilY)) {
+            yup2 = (floorY + ceilY) * 0.5f;
+        }
+    }
+    if (xup != xup2 || yup != yup2 || zup != zup2)
+        return sqrtf((newcam_lookat[0] - xup2) * (newcam_lookat[0] - xup2) + (newcam_lookat[1] - yup2) * (newcam_lookat[1] - yup2) + (newcam_lookat[2] - zup2) * (newcam_lookat[2] - zup2));
+    else
+        return 0;
+}
+
+static void newcam_collision(void)
+{
+    u8 i = 1;
+    u8 col = 0;
+    s16 xup = 0;
+    s16 yup = 0;
+    s16 zup = 0;
+    s16 zoom;
+    zoom = newcam_distance_target;
+
+    while (col == 0 && i < (newcam_distance_target/precision))
+    {
+        xup = newcam_lookat[0]+newcam_pan_x + lengthdir_x(i*precision,newcam_yaw);
+        yup = newcam_lookat[1] + lengthdir_y(i*precision,newcam_tilt);
+        zup = newcam_lookat[2]+newcam_pan_z + lengthdir_y(i*precision,newcam_yaw);
+
+        zoom = newcam_check_geocol(xup,yup,zup);
+        if (zoom !=0)
+            col = 1;
+        i++;
+    }
+    if (zoom != 0)
+    newcam_distance = zoom;
+}
+
+static newcam_round_to_16(s16 val)
+{
+    s16 remainder;
+    if (16 == 0)
+        return val;
+
+    remainder = ABS(val) % 16;
+    if (remainder == 0)
+        return val;
+
+    if (val < 0)
+        return -(ABS(val) - remainder);
+    else
+        return val + 16 - remainder;
+}
+
+static void newcam_set_pan(void)
+{
+    //Apply panning values based on Mario's direction.
+    if (gMarioState->action != ACT_HOLDING_BOWSER && gMarioState->action != ACT_SLEEPING && gMarioState->action != ACT_START_SLEEPING)
+    {
+        approach_f32_asymptotic_bool(&newcam_pan_x, lengthdir_x((160*newcam_panlevel)/100, -gMarioState->faceAngle[1]-0x4000), gDelta*0.05);
+        approach_f32_asymptotic_bool(&newcam_pan_z, lengthdir_y((160*newcam_panlevel)/100, -gMarioState->faceAngle[1]-0x4000), gDelta*0.05);
+    }
+    else
+    {
+        approach_f32_asymptotic_bool(&newcam_pan_x, 0, gDelta*0.05);
+        approach_f32_asymptotic_bool(&newcam_pan_z, 0, gDelta*0.05);
+    }
+
+    newcam_pan_x = newcam_pan_x*(min(newcam_distance/newcam_distance_target,1));
+    newcam_pan_z = newcam_pan_z*(min(newcam_distance/newcam_distance_target,1));
+}
+
+static void newcam_position_cam(void)
+{
+    f32 floorY = 0;
+    f32 floorY2 = 0;
+    s16 shakeX;
+    s16 shakeY;
+
+    if (!(gMarioState->action & ACT_FLAG_SWIMMING))
+        calc_y_to_curr_floor(&floorY, 1.f, 200.f, &floorY2, 0.9f, 200.f);
+
+    newcam_update_values();
+    shakeX = gLakituState.shakeMagnitude[1];
+    shakeY = gLakituState.shakeMagnitude[0];
+    //Fetch Mario's current position. Not hardcoded just for the sake of flexibility, though this specific bit is temp, because it won't always want to be focusing on Mario.
+    newcam_pos_target[0] = gMarioState->pos[0];
+    newcam_pos_target[1] = gMarioState->pos[1]+125;
+    newcam_pos_target[2] = gMarioState->pos[2];
+    //These will set the position of the camera to where Mario is supposed to be, minus adjustments for where the camera should be, on top of.
+    newcam_pos[0] = newcam_pos_target[0]+lengthdir_x(lengthdir_x(newcam_distance,newcam_tilt+shakeX),newcam_yaw+shakeY);
+    newcam_pos[2] = newcam_pos_target[2]+lengthdir_y(lengthdir_x(newcam_distance,newcam_tilt+shakeX),newcam_yaw+shakeY);
+    newcam_pos[1] = newcam_pos_target[1]+lengthdir_y(newcam_distance,newcam_tilt+gLakituState.shakeMagnitude[0])+floorY;
+    newcam_set_pan();
+    //Set where the camera wants to be looking at. This is almost always the place it's based off, too.
+    newcam_lookat[0] = newcam_pos_target[0]-newcam_pan_x;
+    newcam_lookat[1] = newcam_pos_target[1]+floorY2;
+    newcam_lookat[2] = newcam_pos_target[2]-newcam_pan_z;
+    newcam_collision();
+
+}
+
+//Nested if's baybeeeee
+static void newcam_find_fixed(void)
+{
+    u8 i = 0;
+    newcam_mode = newcam_intendedmode;
+    for (i = 0; i < sizeof(newcam_fixedcam); i++)
+    {
+        if (newcam_fixedcam[i].newcam_hard_levelID == gCurrLevelNum && newcam_fixedcam[i].newcam_hard_areaID == gCurrAreaIndex)
+        {
+            if (gMarioState->pos[0] > newcam_fixedcam[i].newcam_hard_X1)
+            if (gMarioState->pos[0] < newcam_fixedcam[i].newcam_hard_X2)
+            if (gMarioState->pos[1] > newcam_fixedcam[i].newcam_hard_Y1)
+            if (gMarioState->pos[1] < newcam_fixedcam[i].newcam_hard_Y2)
+            if (gMarioState->pos[2] > newcam_fixedcam[i].newcam_hard_Z1)
+            if (gMarioState->pos[2] < newcam_fixedcam[i].newcam_hard_Z2)
+            {
+                if (newcam_fixedcam[i].newcam_hard_permaswap)
+                    newcam_intendedmode = newcam_fixedcam[i].newcam_hard_modeset;
+                newcam_mode = newcam_fixedcam[i].newcam_hard_modeset;
+                if (newcam_fixedcam[i].newcam_hard_modeset == NC_MODE_FIXED || newcam_fixedcam[i].newcam_hard_modeset == NC_MODE_FIXED_NOMOVE)
+                {
+                    if (newcam_fixedcam[i].newcam_hard_camX != 32767)
+                        newcam_pos[0] = newcam_fixedcam[i].newcam_hard_camX;
+                    if (newcam_fixedcam[i].newcam_hard_camY != 32767)
+                        newcam_pos[1] = newcam_fixedcam[i].newcam_hard_camY;
+                    if (newcam_fixedcam[i].newcam_hard_camZ != 32767)
+                        newcam_pos[2] = newcam_fixedcam[i].newcam_hard_camZ;
+
+                    if (newcam_fixedcam[i].newcam_hard_modeset == NC_MODE_FIXED_NOMOVE)
+                    {
+                        if (newcam_fixedcam[i].newcam_hard_lookX != 32767)
+                            newcam_lookat[0] = newcam_fixedcam[i].newcam_hard_lookX;
+                        if (newcam_fixedcam[i].newcam_hard_lookY != 32767)
+                            newcam_lookat[1] = newcam_fixedcam[i].newcam_hard_lookY;
+                        if (newcam_fixedcam[i].newcam_hard_lookZ != 32767)
+                            newcam_lookat[2] = newcam_fixedcam[i].newcam_hard_lookZ;
+                    }
+                }
+            }
+        }
+    }
+}
+
+static void newcam_lookat_target(void)
+{
+    //This script is when the camera is fixed. Right now it just stays where it is, but later on, it will add support for the hardcoded camera positions.
+    newcam_pos_target[0] = gMarioState->pos[0];
+    newcam_pos_target[1] = gMarioState->pos[1]+125;
+    newcam_pos_target[2] = gMarioState->pos[2];
+
+    if (newcam_mode == NC_MODE_FIXED)
+    {
+        newcam_set_pan();
+        //Set where the camera wants to be looking at. This is almost always the place it's based off, too.
+        newcam_lookat[0] = newcam_pos_target[0]-newcam_pan_x;
+        newcam_lookat[1] = newcam_pos_target[1];
+        newcam_lookat[2] = newcam_pos_target[2]-newcam_pan_z;
+    }
+
+    newcam_yaw = atan2s(newcam_pos[0]-newcam_pos_target[0],newcam_pos[2]-newcam_pos_target[2]);
+}
+
+static void newcam_apply_values(struct Camera *c)
+{
+
+    c->pos[0] = newcam_pos[0];
+    c->pos[1] = newcam_pos[1];
+    c->pos[2] = newcam_pos[2];
+
+    c->focus[0] = newcam_lookat[0];
+    c->focus[1] = newcam_lookat[1];
+    c->focus[2] = newcam_lookat[2];
+
+    gLakituState.pos[0] = newcam_pos[0];
+    gLakituState.pos[1] = newcam_pos[1];
+    gLakituState.pos[2] = newcam_pos[2];
+
+    gLakituState.focus[0] = newcam_lookat[0];
+    gLakituState.focus[1] = newcam_lookat[1];
+    gLakituState.focus[2] = newcam_lookat[2];
+
+    c->yaw = -newcam_yaw+0x4000;
+    gLakituState.yaw = -newcam_yaw+0x4000;
+
+    //Adds support for wing mario tower
+    if (gMarioState->floor->type == SURFACE_LOOK_UP_WARP) {
+        if (save_file_get_total_star_count(gCurrSaveFileNum - 1, 0, 0x18) >= 10) {
+            if (newcam_tilt < -8000 && gMarioState->forwardVel == 0) {
+                level_trigger_warp(gMarioState, 1);
+            }
+        }
+    }
+
+}
+
+//The ingame cutscene system is such a spaghetti mess I actually have to resort to something as stupid as this to cover every base.
+void newcam_apply_outside_values(struct Camera *c, u8 bit)
+{
+    if (newcam_mode == NC_MODE_NORMAL)
+    {
+        if (bit)
+            newcam_yaw = -gMarioState->faceAngle[1]-0x4000;
+        else
+            newcam_yaw = -c->yaw+0x4000;
+    }
+}
+
+//Main loop.
+void newcam_loop(struct Camera *c)
+{
+    newcam_rotate_button();
+    newcam_zoom_button();
+    newcam_find_fixed();
+    if (newcam_mode != NC_MODE_FIXED && newcam_mode != NC_MODE_FIXED_NOMOVE)
+    newcam_position_cam();
+    else
+    newcam_lookat_target();
+    if (gMarioObject)
+    newcam_apply_values(c);
+
+    //Just some visual information on the values of the camera. utilises ifdef because it's better at runtime.
+    #ifdef NEWCAM_DEBUG
+    newcam_diagnostics();
+    #endif // NEWCAM_DEBUG
+}
+
+
+
+//Displays a box.
+void newcam_display_box(s16 x1, s16 y1, s16 x2, s16 y2, u8 r, u8 g, u8 b)
+{
+    gDPPipeSync(gDisplayListHead++);
+    gDPSetRenderMode(gDisplayListHead++, G_RM_OPA_SURF, G_RM_OPA_SURF2);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_FILL);
+    gDPSetFillColor(gDisplayListHead++, GPACK_RGBA5551(r, g, b, 255));
+    gDPFillRectangle(gDisplayListHead++, x1, y1, x2 - 1, y2 - 1);
+    gDPPipeSync(gDisplayListHead++);
+    gDPSetCycleType(gDisplayListHead++, G_CYC_1CYCLE);
+}
+
+//This is just so I don't have to copypasta a big ass amount of code for 2 very similar events.
+//This is actually spaghetti as fuck but whatever. It fits with SM64's codebase omegaLUL
+void newcam_change_setting(u8 toggle)
+{
+    if (toggle == 0)
+    {
+        switch (newcam_option_selection)
+        {
+            case 0: if (newcam_analogue == 0) newcam_analogue = 1; else newcam_analogue = 0; break;
+            case 1: if (newcam_sensitivityX < 250) newcam_sensitivityX += 1; break;
+            case 2: if (newcam_sensitivityY < 250) newcam_sensitivityY += 1; break;
+            case 3: if (newcam_invertX == 0) newcam_invertX = 1; else newcam_invertX = 0; break;
+            case 4: if (newcam_invertY == 0) newcam_invertY = 1; else newcam_invertY = 0; break;
+            case 5: if (newcam_aggression < 100) newcam_aggression += 1; break;
+            case 6: if (newcam_panlevel < 100) newcam_panlevel += 1; break;
+        }
+    }
+    else
+    {
+        switch (newcam_option_selection)
+        {
+            case 0: if (newcam_analogue == 0) newcam_analogue = 1; else newcam_analogue = 0; break;
+            case 1: if (newcam_sensitivityX > 10) newcam_sensitivityX -= 1; break;
+            case 2: if (newcam_sensitivityY > 10) newcam_sensitivityY -= 1; break;
+            case 3: if (newcam_invertX == 0) newcam_invertX = 1; else newcam_invertX = 0; break;
+            case 4: if (newcam_invertY == 0) newcam_invertY = 1; else newcam_invertY = 0; break;
+            case 5: if (newcam_aggression > 0) newcam_aggression -= 1; break;
+            case 6: if (newcam_panlevel > 0) newcam_panlevel -= 1; break;
+        }
+    }
+}
+/*
+void newcam_change_setting(u8 toggle)
+{
+    if (toggle == 0)
+    {
+        switch (newcam_option_selection)
+        {
+            case 0: if (newcam_analogue == 0) newcam_analogue = 1; else newcam_analogue = 0; break;
+            case 1: if (newcam_sensitivityX < 250) newcam_sensitivityX += 1; break;
+            case 2: if (newcam_sensitivityY < 250) newcam_sensitivityY += 1; break;
+            case 3: if (newcam_invertX == 0) newcam_invertX = 1; else newcam_invertX = 0; break;
+            case 4: if (newcam_invertY == 0) newcam_invertY = 1; else newcam_invertY = 0; break;
+            case 5: if (newcam_aggression < 100) newcam_aggression += 1; break;
+            case 6: if (newcam_panlevel < 100) newcam_panlevel += 1; break;
+        }
+    }
+    else
+    {
+        switch (newcam_option_selection)
+        {
+            case 0: if (newcam_analogue == 0) newcam_analogue = 1; else newcam_analogue = 0; break;
+            case 1: if (newcam_sensitivityX > 10) newcam_sensitivityX -= 1; break;
+            case 2: if (newcam_sensitivityY > 10) newcam_sensitivityY -= 1; break;
+            case 3: if (newcam_invertX == 0) newcam_invertX = 1; else newcam_invertX = 0; break;
+            case 4: if (newcam_invertY == 0) newcam_invertY = 1; else newcam_invertY = 0; break;
+            case 5: if (newcam_aggression > 0) newcam_aggression -= 1; break;
+            case 6: if (newcam_panlevel > 0) newcam_panlevel -= 1; break;
+        }
+    }
+}*/
+
+void newcam_text(s16 x, s16 y, u8 str[], u8 col)
+{
+    u8 textX;
+    textX = get_str_x_pos_from_center(x,str,10.0f);
+    gDPSetEnvColor(gDisplayListHead++, 0, 0, 0, 255);
+    print_generic_string(textX+1,y-1,str);
+    if (col != 0)
+    {
+        gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    }
+    else
+    {
+        gDPSetEnvColor(gDisplayListHead++, 255, 32, 32, 255);
+    }
+    print_generic_string(textX,y,str);
+}
+
+//Options menu
+void newcam_display_options()
+{
+    u8 i = 0;
+    u8 newstring[32];
+    s16 scroll;
+    s16 scrollpos;
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_begin);
+    gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    print_hud_lut_string(HUD_LUT_GLOBAL, 118, 40, newcam_strings[2]);
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_end);
+
+    while (newcam_option_scroll - newcam_option_selection < -3 && newcam_option_selection > newcam_option_scroll)
+        newcam_option_scroll +=1;
+    while (newcam_option_scroll + newcam_option_selection > 0 && newcam_option_selection < newcam_option_scroll)
+        newcam_option_scroll -=1;
+
+    if (newcam_total>4)
+    {
+        newcam_display_box(272,90,280,208,0x80,0x80,0x80);
+        scrollpos = (54)*((f32)newcam_option_scroll/(newcam_total-4));
+        newcam_display_box(272,90+scrollpos,280,154+scrollpos,0xFF,0xFF,0xFF);
+    }
+
+
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 80, SCREEN_WIDTH, SCREEN_HEIGHT);
+    for (i = 0; i < newcam_total; i++)
+    {
+        scroll = 140-(32*i)+(newcam_option_scroll*32);
+        if (scroll <= 140 && scroll > 32)
+        {
+        newcam_text(160,scroll,newcam_options[i],newcam_option_selection-i);
+        switch (i)
+        {
+        case 0:
+            newcam_text(160,scroll-12,newcam_flags[newcam_analogue],newcam_option_selection-i);
+            break;
+        case 1:
+            int_to_str(newcam_sensitivityX,newstring);
+            newcam_text(160,scroll-12,newstring,newcam_option_selection-i);
+            break;
+        case 2:
+            int_to_str(newcam_sensitivityY,newstring);
+            newcam_text(160,scroll-12,newstring,newcam_option_selection-i);
+            break;
+        case 3:
+            newcam_text(160,scroll-12,newcam_flags[newcam_invertX],newcam_option_selection-i);
+            break;
+        case 4:
+            newcam_text(160,scroll-12,newcam_flags[newcam_invertY],newcam_option_selection-i);
+            break;
+        case 5:
+            int_to_str(newcam_aggression,newstring);
+            newcam_text(160,scroll-12,newstring,newcam_option_selection-i);
+            break;
+        case 6:
+            int_to_str(newcam_panlevel,newstring);
+            newcam_text(160,scroll-12,newstring,newcam_option_selection-i);
+            break;
+        }
+        }
+    }
+    gDPSetScissor(gDisplayListHead++, G_SC_NON_INTERLACE, 0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
+    gDPSetEnvColor(gDisplayListHead++, 255, 255, 255, 255);
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_begin);
+    print_hud_lut_string(HUD_LUT_GLOBAL, 80, 90+(32*(newcam_option_selection-newcam_option_scroll)),  newcam_strings[3]);
+    print_hud_lut_string(HUD_LUT_GLOBAL, 224, 90+(32*(newcam_option_selection-newcam_option_scroll)), newcam_strings[3]);
+    gSPDisplayList(gDisplayListHead++, dl_rgba16_text_end);
+    if (gPlayer1Controller->rawStickY >= 60)
+    {
+        newcam_option_timer -= gDelta;
+        if (newcam_option_timer <= 0)
+        {
+            switch (newcam_option_index)
+            {
+                case 0: newcam_option_index++; newcam_option_timer += 10; break;
+                default: newcam_option_timer += 5; break;
+            }
+            #ifndef nosound
+            play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+            #endif
+            newcam_option_selection--;
+            if (newcam_option_selection < 0)
+                newcam_option_selection = newcam_total-1;
+        }
+    }
+    else
+    if (gPlayer1Controller->rawStickY <= -60)
+    {
+        newcam_option_timer -= gDelta;
+        if (newcam_option_timer <= 0)
+        {
+            switch (newcam_option_index)
+            {
+                case 0: newcam_option_index++; newcam_option_timer += 10; break;
+                default: newcam_option_timer += 5; break;
+            }
+            #ifndef nosound
+            play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+            #endif
+            newcam_option_selection++;
+            if (newcam_option_selection >= newcam_total)
+                newcam_option_selection = 0;
+        }
+    }
+    else
+    if (gPlayer1Controller->rawStickX >= 60)
+    {
+        newcam_option_timer -= gDelta;
+        if (newcam_option_timer <= 0)
+        {
+            switch (newcam_option_index)
+            {
+                case 0: newcam_option_index++; newcam_option_timer += 10; break;
+                default: newcam_option_timer += 5; break;
+            }
+            #ifndef nosound
+            play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+            #endif
+            newcam_change_setting(0);
+        }
+    }
+    else
+    if (gPlayer1Controller->rawStickX <= -60)
+    {
+        newcam_option_timer -= gDelta;
+        if (newcam_option_timer <= 0)
+        {
+            switch (newcam_option_index)
+            {
+                case 0: newcam_option_index++; newcam_option_timer += 10; break;
+                default: newcam_option_timer += 5; break;
+            }
+            #ifndef nosound
+            play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+            #endif
+            newcam_change_setting(1);
+        }
+    }
+    else
+    {
+        newcam_option_timer = 0;
+        newcam_option_index = 0;
+    }
+}
+
+void newcam_check_pause_buttons()
+{
+    if (gPlayer1Controller->buttonPressed & R_TRIG)
+    {
+            #ifndef nosound
+            play_sound(SOUND_MENU_CHANGE_SELECT, gDefaultSoundArgs);
+            #endif
+        if (newcam_option_open == 0)
+            newcam_option_open = 1;
+        else
+        {
+            newcam_option_open = 0;
+            save_file_set_setting();
+        }
+
+    }
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_begin);
+    newcam_text(278,212,newcam_strings[newcam_option_open],1);
+    gSPDisplayList(gDisplayListHead++, dl_ia_text_end);
+}
diff --git a/include/segments.h b/include/segments.h
index c98040a..f6bfa63 100644
--- a/include/segments.h
+++ b/include/segments.h
@@ -1,6 +1,8 @@
 #ifndef _SEGMENTS_H
 #define _SEGMENTS_H
 
+#define USE_EXT_RAM
+
 /*
  * Memory addresses for segments. Ideally, this header file would not be
  * needed, and the addresses would be defined in sm64.ld and linker-inserted
@@ -44,10 +46,10 @@
  */
 
 #define SEG_BUFFERS      0x8005C000 // 0x0085000 in size
-#define SEG_MAIN         0x800E1000 // 0x1328000 in size
-#define SEG_ENGINE       0x80213800 // 0x0017000 in size
-#define SEG_FRAMEBUFFERS 0x8022A800 // 0x0070800 in size
-#define SEG_POOL_START   0x8029B000 // 0x0165000 in size
+#define SEG_MAIN         0x800F1000 // 0x1328000 in size
+#define SEG_ENGINE       0x80223800 // 0x0017000 in size
+#define SEG_FRAMEBUFFERS 0x8023A800 // 0x0070800 in size
+#define SEG_POOL_START   0x802AB000 // 0x0165000 in size
 #define SEG_POOL_END     0x80800000
 #define SEG_POOL_END_4MB 0x80400000 // For the error message screen enhancement.
 #define SEG_GODDARD      SEG_POOL_START + 0x113000
diff --git a/include/text_strings.h.in b/include/text_strings.h.in
index 4e36eb9..db30839 100644
--- a/include/text_strings.h.in
+++ b/include/text_strings.h.in
@@ -3,6 +3,20 @@
 
 #include "text_menu_strings.h"
 
+#define NC_CAMX 				_("Camera X Sensitivity")
+    #define NC_CAMY 				_("Camera Y Sensitivity")
+	#define NC_INVERTX				_("Invert X Axis")
+	#define NC_INVERTY				_("Invert Y Axis")
+    #define NC_CAMC 				_("Camera Centre Aggression")
+    #define NC_CAMP 				_("Camera Pan Level")
+    #define NC_ENABLED 				_("Enabled")
+    #define NC_DISABLED 			_("Disabled")
+    #define NC_BUTTON 				_("[R]: Options")
+    #define NC_BUTTON2 				_("[R]: Return")
+	#define NC_OPTION 				_("OPTIONS")
+	#define NC_HIGHLIGHT 			_("O")
+	#define NC_ANALOGUE				_("Analogue Camera")
+
 /**
  * Global Symbols
  */
diff --git a/src/game/camera.c b/src/game/camera.c
index e0bf05f..050e6ba 100644
--- a/src/game/camera.c
+++ b/src/game/camera.c
@@ -701,6 +701,8 @@ f32 calc_y_to_curr_floor(f32 *posOff, f32 posMul, f32 posBound, f32 *focOff, f32
         *focOff = -focBound;
     }
 }
+//Compiler gets mad if I put this any further above. thanks refresh 7
+#include "../../enhancements/bettercamera.inc.c"
 
 void focus_on_mario(Vec3f focus, Vec3f pos, f32 posYOff, f32 focYOff, f32 dist, s16 pitch, s16 yaw) {
     Vec3f marioPos;
@@ -2853,6 +2855,8 @@ void set_camera_mode(struct Camera *c, s16 mode, s16 frames) {
     struct LinearTransitionPoint *start = &sModeInfo.transitionStart;
     struct LinearTransitionPoint *end = &sModeInfo.transitionEnd;
 
+    if (mode != CAM_MODE_NEWCAM && gLakituState.mode != CAM_MODE_NEWCAM)
+    {
     if (mode == CAMERA_MODE_WATER_SURFACE && gCurrLevelArea == AREA_TTM_OUTSIDE) {
     } else {
         // Clear movement flags that would affect the transition
@@ -2896,6 +2900,7 @@ void set_camera_mode(struct Camera *c, s16 mode, s16 frames) {
         vec3f_get_dist_and_angle(start->focus, start->pos, &start->dist, &start->pitch, &start->yaw);
         vec3f_get_dist_and_angle(end->focus, end->pos, &end->dist, &end->pitch, &end->yaw);
     }
+    }
 }
 
 /**
@@ -2980,7 +2985,7 @@ void update_lakitu(struct Camera *c) {
         gLakituState.roll += sHandheldShakeRoll;
         gLakituState.roll += gLakituState.keyDanceRoll;
 
-        if (c->mode != CAMERA_MODE_C_UP && c->cutscene == 0) {
+        if (c->mode != CAMERA_MODE_C_UP && c->cutscene == 0 && c->mode != CAM_MODE_NEWCAM) {
             gCheckingSurfaceCollisionsForCamera = TRUE;
             distToFloor = find_floor(gLakituState.pos[0],
                                      gLakituState.pos[1] + 20.0f,
@@ -3013,7 +3018,7 @@ void update_camera(struct Camera *c) {
     update_camera_hud_status(c);
     if (c->cutscene == 0) {
         // Only process R_TRIG if 'fixed' is not selected in the menu
-        if (cam_select_alt_mode(0) == CAM_SELECTION_MARIO) {
+        if (cam_select_alt_mode(0) == CAM_SELECTION_MARIO && c->mode != CAM_MODE_NEWCAM) {
             if (gPlayer1Controller->buttonPressed & R_TRIG) {
                 if (set_cam_angle(0) == CAM_ANGLE_LAKITU) {
                     set_cam_angle(CAM_ANGLE_MARIO);
@@ -3051,10 +3056,12 @@ void update_camera(struct Camera *c) {
     c->mode = gLakituState.mode;
     c->defMode = gLakituState.defMode;
 
+    if (c->mode != CAM_MODE_NEWCAM)
+    {
     camera_course_processing(c);
     stub_camera_3(c);
-    sCButtonsPressed = find_c_buttons_pressed(sCButtonsPressed, gPlayer1Controller->buttonPressed,
-                                              gPlayer1Controller->buttonDown);
+    sCButtonsPressed = find_c_buttons_pressed(sCButtonsPressed, gPlayer1Controller->buttonPressed,gPlayer1Controller->buttonDown);
+    }
 
     if (c->cutscene != 0) {
         sYawSpeed = 0;
@@ -3092,6 +3099,10 @@ void update_camera(struct Camera *c) {
                     mode_cannon_camera(c);
                     break;
 
+                case CAM_MODE_NEWCAM:
+                    newcam_loop(c);
+                    break;
+
                 default:
                     mode_mario_camera(c);
             }
@@ -3151,6 +3162,10 @@ void update_camera(struct Camera *c) {
                 case CAMERA_MODE_SPIRAL_STAIRS:
                     mode_spiral_stairs_camera(c);
                     break;
+
+                case CAM_MODE_NEWCAM:
+                    newcam_loop(c);
+                    break;
             }
         }
     }
@@ -3426,6 +3441,13 @@ void init_camera(struct Camera *c) {
     gLakituState.nextYaw = gLakituState.yaw;
     c->yaw = gLakituState.yaw;
     c->nextYaw = gLakituState.yaw;
+
+    if (newcam_active == 1)
+    {
+        gLakituState.mode = CAM_MODE_NEWCAM;
+        gLakituState.defMode = CAM_MODE_NEWCAM;
+        newcam_init(c, 0);
+    }
 }
 
 /**
@@ -5514,6 +5536,8 @@ void set_camera_mode_8_directions(struct Camera *c) {
         s8DirModeBaseYaw = 0;
         s8DirModeYawOffset = 0;
     }
+    if (newcam_active == 1)
+        c->mode = CAM_MODE_NEWCAM;
 }
 
 /**
@@ -5532,6 +5556,8 @@ void set_camera_mode_close_cam(u8 *mode) {
         sStatusFlags &= ~CAM_FLAG_SMOOTH_MOVEMENT;
         *mode = CAMERA_MODE_CLOSE;
     }
+    if (newcam_active == 1)
+        *mode = CAM_MODE_NEWCAM;
 }
 
 /**
@@ -5556,6 +5582,8 @@ void set_camera_mode_radial(struct Camera *c, s16 transitionTime) {
         }
         sModeOffsetYaw = 0;
     }
+    if (newcam_active == 1)
+        c->mode = CAM_MODE_NEWCAM;
 }
 
 /**
@@ -6934,6 +6962,7 @@ s16 cutscene_object(u8 cutscene, struct Object *o) {
 void update_camera_yaw(struct Camera *c) {
     c->nextYaw = calculate_yaw(c->focus, c->pos);
     c->yaw = c->nextYaw;
+    newcam_apply_outside_values(c,0);
 }
 
 void cutscene_reset_spline(void) {
@@ -9202,7 +9231,12 @@ BAD_RETURN(s32) cutscene_non_painting_end(struct Camera *c) {
 
     if (c->defMode == CAMERA_MODE_CLOSE) {
         c->mode = CAMERA_MODE_CLOSE;
-    } else {
+    } else
+    if (c->defMode == CAM_MODE_NEWCAM) {
+        c->mode = CAM_MODE_NEWCAM;
+    }
+    else
+    {
         c->mode = CAMERA_MODE_FREE_ROAM;
     }
 
@@ -9958,6 +9992,7 @@ BAD_RETURN(s32) cutscene_sliding_doors_follow_mario(struct Camera *c) {
 BAD_RETURN(s32) cutscene_sliding_doors_open(struct Camera *c) {
     UNUSED u32 pad[2];
 
+    newcam_apply_outside_values(c,1);
     reset_pan_distance(c);
     cutscene_event(cutscene_sliding_doors_open_start, c, 0, 8);
     cutscene_event(cutscene_sliding_doors_open_set_cvars, c, 8, 8);
@@ -10154,7 +10189,10 @@ BAD_RETURN(s32) cutscene_unused_exit_focus_mario(struct Camera *c) {
  * Give control back to the player.
  */
 BAD_RETURN(s32) cutscene_exit_painting_end(struct Camera *c) {
-    c->mode = CAMERA_MODE_CLOSE;
+    if (newcam_active == 1)
+        c->mode = CAM_MODE_NEWCAM;
+        else
+        c->mode = CAMERA_MODE_CLOSE;
     c->cutscene = 0;
     gCutsceneTimer = CUTSCENE_STOP;
     sStatusFlags |= CAM_FLAG_SMOOTH_MOVEMENT;
@@ -10314,10 +10352,15 @@ BAD_RETURN(s32) cutscene_door_follow_mario(struct Camera *c) {
  * Ends the door cutscene. Sets the camera mode to close mode unless the default is free roam.
  */
 BAD_RETURN(s32) cutscene_door_end(struct Camera *c) {
-    if (c->defMode == CAMERA_MODE_FREE_ROAM) {
-        c->mode = CAMERA_MODE_FREE_ROAM;
-    } else {
+    if (c->defMode == CAMERA_MODE_CLOSE) {
         c->mode = CAMERA_MODE_CLOSE;
+    } else
+    if (c->defMode == CAM_MODE_NEWCAM) {
+        c->mode = CAM_MODE_NEWCAM;
+    }
+    else
+    {
+        c->mode = CAMERA_MODE_FREE_ROAM;
     }
 
     c->cutscene = 0;
diff --git a/src/game/camera.h b/src/game/camera.h
index b9aecbe..47032da 100644
--- a/src/game/camera.h
+++ b/src/game/camera.h
@@ -110,6 +110,7 @@
 #define CAMERA_MODE_8_DIRECTIONS      0x0E // AKA Parallel Camera, Bowser Courses & Rainbow Road
 #define CAMERA_MODE_FREE_ROAM         0x10
 #define CAMERA_MODE_SPIRAL_STAIRS     0x11
+#define CAM_MODE_NEWCAM 0x12
 
 #define CAM_MOVE_RETURN_TO_MIDDLE       0x0001
 #define CAM_MOVE_ZOOMED_OUT             0x0002
@@ -655,7 +656,6 @@ struct LakituState
 };
 
 // bss order hack to not affect BSS order. if possible, remove me, but it will be hard to match otherwise
-#ifndef INCLUDED_FROM_CAMERA_C
 // BSS
 extern s16 sSelectionFlags;
 extern s16 sCameraSideCFlags;
@@ -666,7 +666,6 @@ extern struct LakituState gLakituState;
 extern s16 gCameraMovementFlags;
 extern s32 gObjCutsceneDone;
 extern struct Camera *gCamera;
-#endif
 
 extern struct Object *gCutsceneFocus;
 extern struct Object *gSecondCameraFocus;
diff --git a/src/game/game_init.c b/src/game/game_init.c
index d5e5eb3..3f480bb 100644
--- a/src/game/game_init.c
+++ b/src/game/game_init.c
@@ -19,6 +19,7 @@
 #include "main_entry.h"
 #include "thread6.h"
 #include <prevent_bss_reordering.h>
+#include "../../enhancements/bettercamera.h"
 
 // FIXME: I'm not sure all of these variables belong in this file, but I don't
 // know of a good way to split them
@@ -223,7 +224,7 @@ void create_task_structure(void) {
     gGfxSPTask->task.t.dram_stack_size = SP_DRAM_STACK_SIZE8;
     #ifdef VERSION_EU
     // terrible hack
-    gGfxSPTask->task.t.output_buff = 
+    gGfxSPTask->task.t.output_buff =
         (u64 *)((u8 *) gGfxSPTaskOutputBuffer - 0x670 + 0x280);
     gGfxSPTask->task.t.output_buff_size =
         (u64 *)((u8 *) gGfxSPTaskOutputBuffer+ 0x280 + 0x17790);
@@ -601,6 +602,7 @@ void thread5_game_loop(UNUSED void *arg) {
     play_music(SEQ_PLAYER_SFX, SEQUENCE_ARGS(0, SEQ_SOUND_PLAYER), 0);
     set_sound_mode(save_file_get_sound_mode());
     rendering_init();
+    newcam_init_settings();
 
     while (1) {
         // if the reset timer is active, run the process to reset the game.
diff --git a/src/game/ingame_menu.c b/src/game/ingame_menu.c
index 00db061..8fcbf26 100644
--- a/src/game/ingame_menu.c
+++ b/src/game/ingame_menu.c
@@ -18,6 +18,7 @@
 #include "print.h"
 #include "engine/math_util.h"
 #include "course_table.h"
+#include "../../enhancements/bettercamera.h"
 
 extern Gfx *gDisplayListHead;
 extern s16 gCurrCourseNum;
@@ -131,7 +132,7 @@ void create_dl_identity_matrix(void) {
     matrix->m[0][1] = 0x00000000;    matrix->m[1][1] = 0x00010000;    matrix->m[2][1] = 0x00000000;    matrix->m[3][1] = 0x00000000;
     matrix->m[0][2] = 0x00000001;    matrix->m[1][2] = 0x00000000;    matrix->m[2][2] = 0x00000000;    matrix->m[3][2] = 0x00000000;
     matrix->m[0][3] = 0x00000000;    matrix->m[1][3] = 0x00000001;    matrix->m[2][3] = 0x00000000;    matrix->m[3][3] = 0x00000000;
-    
+
     gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(matrix), G_MTX_MODELVIEW | G_MTX_LOAD | G_MTX_NOPUSH);
     gSPMatrix(gDisplayListHead++, VIRTUAL_TO_PHYSICAL(matrix), G_MTX_PROJECTION | G_MTX_LOAD | G_MTX_NOPUSH);
 }
@@ -688,7 +689,7 @@ void print_credits_string(s16 x, s16 y, const u8 *str) {
     gDPSetTile(gDisplayListHead++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 0, 0, G_TX_LOADTILE, 0,
                 G_TX_WRAP | G_TX_NOMIRROR, G_TX_NOMASK, G_TX_NOLOD, G_TX_WRAP | G_TX_NOMIRROR, G_TX_NOMASK, G_TX_NOLOD);
     gDPTileSync(gDisplayListHead++);
-    gDPSetTile(gDisplayListHead++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 2, 0, G_TX_RENDERTILE, 0, 
+    gDPSetTile(gDisplayListHead++, G_IM_FMT_RGBA, G_IM_SIZ_16b, 2, 0, G_TX_RENDERTILE, 0,
                 G_TX_CLAMP, 3, G_TX_NOLOD, G_TX_CLAMP, 3, G_TX_NOLOD);
     gDPSetTileSize(gDisplayListHead++, G_TX_RENDERTILE, 0, 0, (8 - 1) << G_TEXTURE_IMAGE_FRAC, (8 - 1) << G_TEXTURE_IMAGE_FRAC);
 
@@ -2587,7 +2588,8 @@ s16 render_pause_courses_and_castle(void) {
 #ifdef VERSION_EU
     gInGameLanguage = eu_get_language();
 #endif
-
+    if (newcam_option_open == 0)
+    {
     switch (gDialogBoxState) {
         case DIALOG_STATE_OPENING:
             gDialogLineNum = 1;
@@ -2663,6 +2665,13 @@ s16 render_pause_courses_and_castle(void) {
     if (gDialogTextAlpha < 250) {
         gDialogTextAlpha += 25;
     }
+    }
+    else
+    {
+        shade_screen();
+        newcam_display_options();
+    }
+    newcam_check_pause_buttons();
 
     return 0;
 }
diff --git a/src/game/mario.c b/src/game/mario.c
index aace34f..2729478 100644
--- a/src/game/mario.c
+++ b/src/game/mario.c
@@ -31,6 +31,7 @@
 #include "engine/surface_collision.h"
 #include "level_table.h"
 #include "thread6.h"
+#include "../../enhancements/bettercamera.h"
 
 u32 unused80339F10;
 s8 filler80339F1C[20];
@@ -350,7 +351,7 @@ void play_mario_heavy_landing_sound_once(struct MarioState *m, u32 soundBits) {
 void play_mario_sound(struct MarioState *m, s32 actionSound, s32 marioSound) {
     if (actionSound == SOUND_ACTION_TERRAIN_JUMP) {
         play_mario_action_sound(
-                m, (m->flags & MARIO_METAL_CAP) ? (s32)SOUND_ACTION_METAL_JUMP 
+                m, (m->flags & MARIO_METAL_CAP) ? (s32)SOUND_ACTION_METAL_JUMP
                                                 : (s32)SOUND_ACTION_TERRAIN_JUMP, 1);
     } else {
         play_sound_if_no_flag(m, actionSound, MARIO_ACTION_SOUND_PLAYED);
@@ -1306,7 +1307,10 @@ void update_mario_joystick_inputs(struct MarioState *m) {
     }
 
     if (m->intendedMag > 0.0f) {
-        m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
+        if (gLakituState.mode != CAM_MODE_NEWCAM)
+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
+        else
+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX)-newcam_yaw+0x4000;
         m->input |= INPUT_NONZERO_ANALOG;
     } else {
         m->intendedYaw = m->faceAngle[1];
diff --git a/src/game/mario_actions_airborne.c b/src/game/mario_actions_airborne.c
index 92e5dab..2431fc0 100644
--- a/src/game/mario_actions_airborne.c
+++ b/src/game/mario_actions_airborne.c
@@ -13,6 +13,7 @@
 #include "audio/external.h"
 #include "engine/graph_node.h"
 #include "thread6.h"
+#include "../../enhancements/bettercamera.h"
 
 void play_flip_sounds(struct MarioState *m, s16 frame1, s16 frame2, s16 frame3) {
     s32 animFrame = m->marioObj->header.gfx.unk38.animFrame;
@@ -455,8 +456,8 @@ s32 act_jump(struct MarioState *m) {
 }
 
 s32 act_double_jump(struct MarioState *m) {
-    s32 animation = (m->vel[1] >= 0.0f) 
-        ? MARIO_ANIM_DOUBLE_JUMP_RISE 
+    s32 animation = (m->vel[1] >= 0.0f)
+        ? MARIO_ANIM_DOUBLE_JUMP_RISE
         : MARIO_ANIM_DOUBLE_JUMP_FALL;
 
     if (check_kick_or_dive_in_air(m)) {
@@ -1676,7 +1677,13 @@ s32 act_shot_from_cannon(struct MarioState *m) {
         case AIR_STEP_LANDED:
             set_mario_action(m, ACT_DIVE_SLIDE, 0);
             m->faceAngle[0] = 0;
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
 #ifdef VERSION_SH
             queue_rumble_data(5, 80);
 #endif
@@ -1692,7 +1699,13 @@ s32 act_shot_from_cannon(struct MarioState *m) {
 
             m->particleFlags |= PARTICLE_VERTICAL_STAR;
             set_mario_action(m, ACT_BACKWARD_AIR_KB, 0);
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
             break;
 
         case AIR_STEP_HIT_LAVA_WALL:
@@ -1722,20 +1735,38 @@ s32 act_flying(struct MarioState *m) {
 
     if (m->input & INPUT_Z_PRESSED) {
         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
         }
         return set_mario_action(m, ACT_GROUND_POUND, 1);
     }
 
     if (!(m->flags & MARIO_WING_CAP)) {
         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
         }
         return set_mario_action(m, ACT_FREEFALL, 0);
     }
 
     if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
-        set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
     }
 
     if (m->actionState == 0) {
@@ -1775,7 +1806,13 @@ s32 act_flying(struct MarioState *m) {
             set_anim_to_frame(m, 7);
 
             m->faceAngle[0] = 0;
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
 #ifdef VERSION_SH
             queue_rumble_data(5, 80);
 #endif
@@ -1796,7 +1833,13 @@ s32 act_flying(struct MarioState *m) {
 
                 m->particleFlags |= PARTICLE_VERTICAL_STAR;
                 set_mario_action(m, ACT_BACKWARD_AIR_KB, 0);
+            if (newcam_active == 0)
                 set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
             } else {
                 if (m->actionTimer++ == 0) {
                     play_sound(SOUND_ACTION_HIT, m->marioObj->header.gfx.cameraToObject);
@@ -1877,7 +1920,13 @@ s32 act_flying_triple_jump(struct MarioState *m) {
 #ifndef VERSION_JP
     if (m->input & (INPUT_B_PRESSED | INPUT_Z_PRESSED)) {
         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
         }
         if (m->input & INPUT_B_PRESSED) {
             return set_mario_action(m, ACT_DIVE, 0);
@@ -1918,7 +1967,13 @@ s32 act_flying_triple_jump(struct MarioState *m) {
 
     if (m->vel[1] < 4.0f) {
         if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
-            set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
+            if (newcam_active == 0)
+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
+            else
+            {
+                m->area->camera->mode = CAM_MODE_NEWCAM;
+                gLakituState.mode = CAM_MODE_NEWCAM;
+            }
         }
 
         if (m->forwardVel < 32.0f) {
@@ -1928,10 +1983,6 @@ s32 act_flying_triple_jump(struct MarioState *m) {
         set_mario_action(m, ACT_FLYING, 1);
     }
 
-    if (m->actionTimer++ == 10 && m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
-        set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
-    }
-
     update_air_without_turn(m);
 
     switch (perform_air_step(m, 0)) {
diff --git a/src/game/save_file.c b/src/game/save_file.c
index 6803fb6..238e59c 100644
--- a/src/game/save_file.c
+++ b/src/game/save_file.c
@@ -11,11 +11,13 @@
 #include "level_table.h"
 #include "course_table.h"
 #include "thread6.h"
+#include "../../enhancements/bettercamera.h"
 
 #define MENU_DATA_MAGIC 0x4849
 #define SAVE_FILE_MAGIC 0x4441
 
-STATIC_ASSERT(sizeof(struct SaveBuffer) == EEPROM_SIZE, "eeprom buffer size must match");
+STATIC_ASSERT(sizeof(struct SaveBuffer) <= EEPROM_SIZE, "eeprom buffer size higher than intended");
+STATIC_ASSERT(sizeof(struct SaveBuffer) >= EEPROM_SIZE, "eeprom buffer size lower than intended");
 
 extern struct SaveBuffer gSaveBuffer;
 
@@ -565,6 +567,48 @@ u16 save_file_get_sound_mode(void) {
     return gSaveBuffer.menuData[0].soundMode;
 }
 
+void save_file_set_setting(void) {
+
+    gSaveBuffer.menuData[0].camx = newcam_sensitivityX;
+    gSaveBuffer.menuData[0].camy = newcam_sensitivityY;
+    gSaveBuffer.menuData[0].invertx = newcam_invertX;
+    gSaveBuffer.menuData[0].inverty = newcam_invertY;
+    gSaveBuffer.menuData[0].camc = newcam_aggression;
+    gSaveBuffer.menuData[0].camp = newcam_panlevel;
+    gSaveBuffer.menuData[0].analogue = newcam_analogue;
+
+    gSaveBuffer.menuData[0].firsttime = 1;
+
+
+    gMainMenuDataModified = TRUE;
+    save_main_menu_data();
+}
+
+u16 save_file_get_setting(void) {
+        newcam_sensitivityX = gSaveBuffer.menuData[0].camx;
+        newcam_sensitivityY = gSaveBuffer.menuData[0].camy;
+        newcam_invertX = gSaveBuffer.menuData[0].invertx;
+        newcam_invertY = gSaveBuffer.menuData[0].inverty;
+        newcam_aggression = gSaveBuffer.menuData[0].camc;
+        newcam_panlevel = gSaveBuffer.menuData[0].camp;
+        newcam_analogue = gSaveBuffer.menuData[0].analogue;
+
+}
+
+u16 save_check_firsttime(void)
+{
+    return gSaveBuffer.menuData[0].firsttime;
+}
+
+
+u16 save_set_firsttime(void)
+{
+    gSaveBuffer.menuData[0].firsttime = 1;
+
+    gMainMenuDataModified = TRUE;
+    save_main_menu_data();
+}
+
 void save_file_move_cap_to_default_location(void) {
     if (save_file_get_flags() & SAVE_FLAG_CAP_ON_GROUND) {
         switch (gSaveBuffer.files[gCurrSaveFileNum - 1][0].capLevel) {
diff --git a/src/game/save_file.h b/src/game/save_file.h
index 198748d..7a7df6c 100644
--- a/src/game/save_file.h
+++ b/src/game/save_file.h
@@ -6,7 +6,7 @@
 
 #include "course_table.h"
 
-#define EEPROM_SIZE 0x200
+#define EEPROM_SIZE 0x800
 #define NUM_SAVE_FILES 4
 
 struct SaveBlockSignature
@@ -50,16 +50,24 @@ struct MainMenuSaveData
     // on the high score screen.
     u32 coinScoreAges[NUM_SAVE_FILES];
     u16 soundMode;
-
+    u8 camx;
+    u8 camy;
+    u8 analogue;
+    u8 invertx;
+    u8 inverty;
+    u8 camc;
+    u8 camp;
+    u8 firsttime;
 #ifdef VERSION_EU
     u16 language;
 #define SUBTRAHEND 8
 #else
-#define SUBTRAHEND 6
+#define SUBTRAHEND 15
 #endif
 
+
     // Pad to match the EEPROM size of 0x200 (10 bytes on JP/US, 8 bytes on EU)
-    u8 filler[EEPROM_SIZE / 2 - SUBTRAHEND - NUM_SAVE_FILES * (4 + sizeof(struct SaveFile))];
+    //u8 filler[EEPROM_SIZE / 2 - SUBTRAHEND - NUM_SAVE_FILES * (4 + sizeof(struct SaveFile))];
 
     struct SaveBlockSignature signature;
 };
@@ -70,6 +78,7 @@ struct SaveBuffer
     struct SaveFile files[NUM_SAVE_FILES][2];
     // The main menu data has two copies. If one is bad, the other is used as a backup.
     struct MainMenuSaveData menuData[2];
+    u8 filler[1535]; //!I still haven't done an algorithm for this yet lol
 };
 
 struct WarpNode;
