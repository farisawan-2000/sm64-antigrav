src/goddard/objects.c:    newCam->id = gGdCameraCount;
src/goddard/objects.c:        newCam->next = oldCameraHead;
src/goddard/objects.c:    newCam->unk2C = a0 | 0x10;
src/goddard/objects.c:    newCam->unk30 = a1;
src/goddard/objects.c:    gd_set_identity_mat4(&newCam->unk64);
src/goddard/objects.c:    gd_set_identity_mat4(&newCam->unkA8);
src/goddard/objects.c:    newCam->unk180.x = 1.0f;
src/goddard/objects.c:    newCam->unk180.y = 0.1f;
src/goddard/objects.c:    newCam->unk180.z = 1.0f;
src/goddard/objects.c:    newCam->unk134.x = 4.0f;
src/goddard/objects.c:    newCam->unk134.y = 4.0f;
src/goddard/objects.c:    newCam->unk134.z = 4.0f;
src/goddard/objects.c:    newCam->unk178 = 0.0f;
src/goddard/objects.c:    newCam->unk17C = 0.25f;
src/goddard/objects.c:    newCam->zoom = 0;
src/goddard/objects.c:    newCam->zoomLevels = -1;
src/goddard/objects.c:    newCam->unkA4 = 0.0f;
src/goddard/objects.c:    newCam->unk34.x = newCam->unk34.y = newCam->unk34.z = 0.0f;
src/goddard/objects.c:    newCam->unk14.x = newCam->unk14.y = newCam->unk14.z = 0.0f;
src/goddard/objects.c:    newAnim->unk24 = 1.0f;
src/goddard/objects.c:    newAnim->unk28 = 1.0f;
src/goddard/objects.c:    newAnim->fn48 = NULL;
src/goddard/objects.c:    newAnim->unk4C = 0;
src/goddard/objects.c:    if ((cam->unk2C & 0x10) == 0) {
src/goddard/objects.c:    if ((spEC = cam->unk30) != NULL) {
src/goddard/objects.c:        spC8.x = sp70[2][0] - cam->unk58;
src/goddard/objects.c:        spC8.z = sp70[2][2] - cam->unk60;
src/goddard/objects.c:        cam->unk58 += spC8.x * cam->unk180.y;
src/goddard/objects.c:        cam->unk60 += spC8.z * cam->unk180.y;
src/goddard/objects.c:        cam->unkA8[2][0] = cam->unk58;
src/goddard/objects.c:        cam->unkA8[2][1] = 0.0f;
src/goddard/objects.c:        cam->unkA8[2][2] = cam->unk60;
src/goddard/objects.c:        cam->unkA8[0][0] = cam->unkA8[2][2];
src/goddard/objects.c:        cam->unkA8[0][1] = 0.0f;
src/goddard/objects.c:        cam->unkA8[0][2] = -cam->unkA8[2][0];
src/goddard/objects.c:        cam->unkA8[1][0] = 0.0f;
src/goddard/objects.c:        cam->unkA8[1][1] = 1.0f;
src/goddard/objects.c:        cam->unkA8[1][2] = 0.0f;
src/goddard/objects.c:        gd_set_identity_mat4(&cam->unkA8);
src/goddard/objects.c:        gd_set_identity_mat4(&cam->unkA8);
src/goddard/objects.c:    sp2C = &cam->unk64;
src/goddard/objects.c:    if ((cam->unk2C & 0x4) != 0) { // new B press
src/goddard/objects.c:            cam->zoom++;
src/goddard/objects.c:            if (cam->zoom > cam->zoomLevels) {
src/goddard/objects.c:                cam->zoom = 0;
src/goddard/objects.c:            switch (cam->zoom) {
src/goddard/objects.c:            cam->unk128.y += cam->unk134.y;
src/goddard/objects.c:            cam->unk128.y -= cam->unk134.y;
src/goddard/objects.c:            cam->unk128.x += cam->unk134.x;
src/goddard/objects.c:            cam->unk128.x -= cam->unk134.x;
src/goddard/objects.c:        cam->unk128.x = gd_clamp_f32(cam->unk128.x, 80.0f);
src/goddard/objects.c:        cam->unk4C.x = cam->positions[cam->zoom].x;
src/goddard/objects.c:        cam->unk4C.y = cam->positions[cam->zoom].y;
src/goddard/objects.c:        cam->unk4C.z = cam->positions[cam->zoom].z;
src/goddard/objects.c:        gd_rot_2d_vec(cam->unk128.x, &cam->unk4C.y, &cam->unk4C.z);
src/goddard/objects.c:        gd_rot_2d_vec(-cam->unk128.y, &cam->unk4C.x, &cam->unk4C.z);
src/goddard/objects.c:        cam->unk40.x += (cam->unk4C.x - cam->unk40.x) * cam->unk17C;
src/goddard/objects.c:        cam->unk40.y += (cam->unk4C.y - cam->unk40.y) * cam->unk17C;
src/goddard/objects.c:        cam->unk40.z += (cam->unk4C.z - cam->unk40.z) * cam->unk17C;
src/goddard/objects.c:    spD4.x = cam->unk40.x;
src/goddard/objects.c:    spD4.y = cam->unk40.y;
src/goddard/objects.c:    spD4.z = cam->unk40.z;
src/goddard/objects.c:    gd_mult_mat4f(sp2C, &cam->unkA8, &cam->unkA8);
src/goddard/objects.c:    gd_mat4f_mult_vec3f(&spD4, &cam->unkA8);
src/goddard/objects.c:    cam->unk14.x = spD4.x;
src/goddard/objects.c:    cam->unk14.y = spD4.y;
src/goddard/objects.c:    cam->unk14.z = spD4.z;
src/goddard/objects.c:    cam->unk14.x += spE0.x;
src/goddard/objects.c:    cam->unk14.y += spE0.y;
src/goddard/objects.c:    cam->unk14.z += spE0.z;
src/goddard/renderer.c:    gd_mat4f_lookat(&cam->unkE8, arg1, arg2, arg3, arg4, arg5, arg6, gd_sin_d(arg7), gd_cos_d(arg7),
src/goddard/renderer.c:    mat4_to_mtx(&cam->unkE8, &DL_CURRENT_MTX(sCurrentGdDl));
src/goddard/renderer.c:    lookat->l[0].l.dir[0] = LOOKAT_PACK(cam->unkE8[0][0]);
src/goddard/renderer.c:    lookat->l[0].l.dir[1] = LOOKAT_PACK(cam->unkE8[1][0]);
src/goddard/renderer.c:    lookat->l[0].l.dir[2] = LOOKAT_PACK(cam->unkE8[2][0]);
src/goddard/renderer.c:    lookat->l[1].l.dir[0] = LOOKAT_PACK(cam->unkE8[0][1]);
src/goddard/renderer.c:    lookat->l[1].l.dir[1] = LOOKAT_PACK(cam->unkE8[1][1]);
src/goddard/renderer.c:    lookat->l[1].l.dir[2] = LOOKAT_PACK(cam->unkE8[2][1]);
src/goddard/renderer.c:    sp40.z = cam->unkE8[0][2] + arg4->x;
src/goddard/renderer.c:    sp40.y = cam->unkE8[1][2] + arg4->y;
src/goddard/renderer.c:    sp40.x = cam->unkE8[2][2] + arg4->z;
src/goddard/renderer.c:            (((sp40.z * cam->unkE8[0][0]) + (sp40.y * cam->unkE8[1][0]) + (sp40.x * cam->unkE8[2][0]))
src/goddard/renderer.c:            (((sp40.z * cam->unkE8[0][1]) + (sp40.y * cam->unkE8[1][1]) + (sp40.x * cam->unkE8[2][1]))
src/goddard/renderer.c:    sVtxCvrtNormBuf[0] = (s8)(norm->x * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[1] = (s8)(norm->y * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[2] = (s8)(norm->z * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[0] = (s8)(norm->x * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[1] = (s8)(norm->y * 127.0f);
src/goddard/renderer.c:    sVtxCvrtNormBuf[2] = (s8)(norm->z * 127.0f);
src/goddard/gd_math.c: * Matrix has form-  | -(cz+sxy)/h sh  (cx-syz)/h 0 |
src/goddard/gd_math.c: * Has form-
src/goddard/gd_math.c: * Matrix has form-
src/goddard/dynlist_proc.c:    while (num--) {
src/goddard/draw_objects.c:    if (cam->unk30 != NULL) {
src/goddard/draw_objects.c:        set_cur_dynobj(cam->unk30);
src/goddard/draw_objects.c:        sp44.x += cam->unk34.x;
src/goddard/draw_objects.c:        sp44.y += cam->unk34.y;
src/goddard/draw_objects.c:        sp44.z += cam->unk34.z;
src/goddard/draw_objects.c:        sp44.x = cam->unk34.x;
src/goddard/draw_objects.c:        sp44.y = cam->unk34.y;
src/goddard/draw_objects.c:        sp44.z = cam->unk34.z;
src/goddard/draw_objects.c:        gd_printf("%f,%f,%f\n", cam->unk14.x, cam->unk14.y, cam->unk14.z);
src/goddard/draw_objects.c:    if (ABS(cam->unk14.x - sp44.x) + ABS(cam->unk14.z - sp44.z) == 0.0f) {
src/goddard/draw_objects.c:    func_8019F318(cam, cam->unk14.x, cam->unk14.y, cam->unk14.z, sp44.x, sp44.y, sp44.z, cam->unkA4);
src/goddard/draw_objects.c:    gd_rotate_and_translate_vec3f(pos, &cam->unkE8);
src/audio/seqplayer.c:        if (item->prev == NULL) {
src/audio/seqplayer.c:            item->prev = gLayerFreeList.prev;
src/audio/seqplayer.c:            item->next = &gLayerFreeList;
src/audio/seqplayer.c:            item->pool = gLayerFreeList.pool;
src/audio/seqplayer.c:    if (item->prev == NULL) {
src/audio/seqplayer.c:        item->prev = list->prev;
src/audio/seqplayer.c:        item->next = list;
src/audio/seqplayer.c:        item->pool = list->pool;
src/audio/seqplayer.c:    item->prev->next = list;
src/audio/seqplayer.c:    list->prev = item->prev;
src/audio/seqplayer.c:    item->prev = NULL;
src/audio/seqplayer.c:    return item->u.value;
src/audio/seqplayer.c:                    layer->adsr.envelope = drum->envelope;
src/audio/seqplayer.c:                    layer->adsr.releaseRate = drum->releaseRate;
src/audio/seqplayer.c:                        layer->pan = drum->pan;
src/audio/seqplayer.c:                    layer->pan = FLOAT_CAST(drum->pan) / US_FLOAT(128.0);
src/audio/seqplayer.c:                    layer->sound = &drum->sound;
src/audio/load.c:    drums = mem->drums;
src/audio/load.c:        mem->drums = (void *)((uintptr_t) drums + (uintptr_t) mem);
src/audio/load.c:        mem->drums = PATCH(drums, mem);
src/audio/load.c:            patched = mem->drums[i];
src/audio/load.c:                mem->drums[i] = drum;
src/audio/load.c:                if (drum->loaded == 0) {
src/audio/load.c:                    drum->envelope = (void *)((uintptr_t) mem + (uintptr_t) patched);
src/audio/load.c:                    patch_sound(&drum->sound, (u8 *) mem, offset);
src/audio/load.c:                    patched = drum->envelope;
src/audio/load.c:                    drum->envelope = (void *)((uintptr_t) patched + (uintptr_t) mem);
src/audio/load.c:                    drum->loaded = 1;
src/audio/synthesis.c:            osInvalDCache(item->toDownsampleLeft, DEFAULT_LEN_2CH);
src/audio/synthesis.c:            for (srcPos = 0, dstPos = 0; dstPos < item->lengths[0] / 2;
src/audio/synthesis.c:                reverb->ringBuffer.left[item->startPos + dstPos] =
src/audio/synthesis.c:                    item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                reverb->ringBuffer.right[item->startPos + dstPos] =
src/audio/synthesis.c:                    item->toDownsampleRight[srcPos];
src/audio/synthesis.c:            for (dstPos = 0; dstPos < item->lengths[1] / 2; srcPos += reverb->downsampleRate, dstPos++) {
src/audio/synthesis.c:                reverb->ringBuffer.left[dstPos] = item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                reverb->ringBuffer.right[dstPos] = item->toDownsampleRight[srcPos];
src/audio/synthesis.c:        item->lengths[0] = nSamples * 2;
src/audio/synthesis.c:        item->lengths[1] = 0;
src/audio/synthesis.c:        item->startPos = (s32) reverb->nextRingBufferPos;
src/audio/synthesis.c:        item->lengths[0] = (nSamples - excessiveSamples) * 2;
src/audio/synthesis.c:        item->lengths[1] = excessiveSamples * 2;
src/audio/synthesis.c:        item->startPos = reverb->nextRingBufferPos;
src/audio/synthesis.c:    item->numSamplesAfterDownsampling = nSamples;
src/audio/synthesis.c:    item->chunkLen = chunkLen;
src/audio/synthesis.c:            osInvalDCache(item->toDownsampleLeft, DEFAULT_LEN_2CH);
src/audio/synthesis.c:            for (srcPos = 0, dstPos = 0; dstPos < item->lengths[0] / 2;
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.left[dstPos + item->startPos] =
src/audio/synthesis.c:                    item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.right[dstPos + item->startPos] =
src/audio/synthesis.c:                    item->toDownsampleRight[srcPos];
src/audio/synthesis.c:            for (dstPos = 0; dstPos < item->lengths[1] / 2; srcPos += gReverbDownsampleRate, dstPos++) {
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.left[dstPos] = item->toDownsampleLeft[srcPos];
src/audio/synthesis.c:                gSynthesisReverb.ringBuffer.right[dstPos] = item->toDownsampleRight[srcPos];
src/audio/synthesis.c:        item->lengths[0] = numSamplesAfterDownsampling * 2;
src/audio/synthesis.c:        item->lengths[1] = 0;
src/audio/synthesis.c:        item->startPos = (s32) gSynthesisReverb.nextRingBufferPos;
src/audio/synthesis.c:        item->lengths[0] = nSamples * 2;
src/audio/synthesis.c:        item->lengths[1] = excessiveSamples * 2;
src/audio/synthesis.c:        item->startPos = gSynthesisReverb.nextRingBufferPos;
src/audio/synthesis.c:    item->numSamplesAfterDownsampling = numSamplesAfterDownsampling;
src/audio/synthesis.c:    item->chunkLen = chunkLen;
src/audio/synthesis.c:        cmd = synthesis_load_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH, item->startPos, item->lengths[0], reverbIndex);
src/audio/synthesis.c:        if (item->lengths[1] != 0) {
src/audio/synthesis.c:            cmd = synthesis_load_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH + item->lengths[0], 0, item->lengths[1], reverbIndex);
src/audio/synthesis.c:        temp_t9 = (item->startPos % 8u) * 2;
src/audio/synthesis.c:        sp58 = ALIGN(item->lengths[0] + (sp58=temp_t9), 4);
src/audio/synthesis.c:        cmd = synthesis_load_reverb_ring_buffer(cmd, 0x20, (item->startPos - temp_t9 / 2), DEFAULT_LEN_1CH, reverbIndex);
src/audio/synthesis.c:        if (item->lengths[1] != 0) {
src/audio/synthesis.c:            cmd = cmdBuf = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH, item->startPos, item->lengths[0], reverbIndex);
src/audio/synthesis.c:            if (item->lengths[1] != 0) {
src/audio/synthesis.c:                cmd = synthesis_save_reverb_ring_buffer(cmd, DMEM_ADDR_WET_LEFT_CH + item->lengths[0], 0, item->lengths[1], reverbIndex);
src/audio/playback.c:    if (item->prev == NULL) {
src/audio/playback.c:        item->prev = list;
src/audio/playback.c:        item->next = list->next;
src/audio/playback.c:        item->pool = list->pool;
src/audio/playback.c:    if (item->prev != NULL) {
src/audio/playback.c:        item->prev->next = item->next;
src/audio/playback.c:        item->next->prev = item->prev;
src/audio/playback.c:        item->prev = NULL;
src/engine/graph_node.c:        graphNode->unk38.animFrame = anim->unk04 + ((anim->flags & ANIM_FLAG_FORWARD) ? 1 : -1);
src/engine/graph_node.c:            (anim->unk04 << 16) + ((anim->flags & ANIM_FLAG_FORWARD) ? animAccel : -animAccel);
src/engine/graph_node.c:    if (obj->animTimer == gAreaUpdateCounter || anim->flags & ANIM_FLAG_2) {
src/engine/graph_node.c:    if (anim->flags & ANIM_FLAG_FORWARD) {
src/engine/graph_node.c:        if (GET_HIGH_S16_OF_32(result) < anim->unk06) {
src/engine/graph_node.c:            if (anim->flags & ANIM_FLAG_NOLOOP) {
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->unk06);
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->unk08 - 1);
src/engine/graph_node.c:        if (GET_HIGH_S16_OF_32(result) >= anim->unk08) {
src/engine/graph_node.c:            if (anim->flags & ANIM_FLAG_NOLOOP) {
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->unk08 - 1);
src/engine/graph_node.c:                SET_HIGH_S16_OF_32(result, anim->unk06);
src/game/camera.c:    if ((m->action == ACT_SLEEPING) || (m->action == ACT_START_SLEEPING)) {
src/game/camera.c:    if (m->area->camera->cutscene == CUTSCENE_0F_UNUSED) {
src/game/camera.c:    if (m->area->camera->mode == CAMERA_MODE_FIXED && m->area->camera->cutscene == 0) {
src/game/camera.c:    if (m->area->camera->mode == CAMERA_MODE_FIXED && m->area->camera->cutscene == 0) {
src/game/level_update.c:            m->flags |= MARIO_METAL_CAP | MARIO_CAP_ON_HEAD;
src/game/level_update.c:            m->capTimer = 600;
src/game/level_update.c:            m->flags |= MARIO_WING_CAP | MARIO_CAP_ON_HEAD;
src/game/level_update.c:            m->capTimer = 1200;
src/game/level_update.c:            m->flags |= MARIO_VANISH_CAP | MARIO_CAP_ON_HEAD;
src/game/level_update.c:            m->capTimer = 600;
src/game/level_update.c:        m->invincTimer = -1;
src/game/level_update.c:                if (m->numLives == 0) {
src/game/level_update.c:                    if (m->numLives == 0) {
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/level_update.c:                sDelayedWarpArg = m->actionArg;
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/level_update.c:                sSourceWarpNodeId = (m->usedObj->oBehParams & 0x00FF0000) >> 16;
src/game/debug.c:s16 gDebugPrintState2[6]; // prints bottom-up?
src/game/debug.c:    sprintf(fHeight, "%.2f", m->floorHeight);
src/game/debug.c:    sprintf(hSpd, "%.2f", m->forwardVel);
src/game/debug.c:    sprintf(cHeight, "%.2f", m->ceilHeight);
src/game/debug.c:    f32 floorDist = m->pos[1] - find_surface_down(m->pos[0], m->pos[1], m->pos[2], &m->floor);
src/game/debug.c:    f32 ceilDist = find_surface_up(m->pos[0], m->pos[1], m->pos[2], &m->ceil) - m->pos[1];
src/game/debug.c:        m->faceAngle[0] = 0x0000;
src/game/debug.c:        m->faceAngle[0] = 0x8000;
src/game/ingame_menu.c:                gDialogLineNum--;
src/game/mario_actions_cutscene.c:        if (m->unkB8 < numStarsRequired && m->numStars >= numStarsRequired) {
src/game/mario_actions_cutscene.c:    m->unkB8 = m->numStars;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    struct Object *o = spawn_object(m->marioObj, model, behavior);
src/game/mario_actions_cutscene.c:    o->oFaceAngleYaw = m->faceAngle[1] + relYaw;
src/game/mario_actions_cutscene.c:    o->oPosX = m->pos[0];
src/game/mario_actions_cutscene.c:    o->oPosY = m->pos[1];
src/game/mario_actions_cutscene.c:    o->oPosZ = m->pos[2];
src/game/mario_actions_cutscene.c:    m->flags &= ~MARIO_CAP_ON_HEAD;
src/game/mario_actions_cutscene.c:    m->flags |= MARIO_CAP_IN_HAND;
src/game/mario_actions_cutscene.c:    play_sound(SOUND_ACTION_UNKNOWN43D, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    m->flags &= ~MARIO_CAP_IN_HAND;
src/game/mario_actions_cutscene.c:    m->flags |= MARIO_CAP_ON_HEAD;
src/game/mario_actions_cutscene.c:    play_sound(SOUND_ACTION_UNKNOWN43E, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    if (m->actionArg == 2) {
src/game/mario_actions_cutscene.c:    if (m->actionArg == 3) {
src/game/mario_actions_cutscene.c:    if (m->actionState < 8) {
src/game/mario_actions_cutscene.c:        angleToNPC = mario_obj_angle_to_object(m, m->usedObj);
src/game/mario_actions_cutscene.c:        m->faceAngle[1] =
src/game/mario_actions_cutscene.c:            angleToNPC - approach_s32((angleToNPC - m->faceAngle[1]) << 16 >> 16, 0, 2048, 2048);
src/game/mario_actions_cutscene.c:        m->actionTimer += headTurnAmount;
src/game/mario_actions_cutscene.c:        set_mario_animation(m, m->heldObj == NULL ? MARIO_ANIM_FIRST_PERSON
src/game/mario_actions_cutscene.c:    } else if (m->actionState >= 9 && m->actionState < 17) {
src/game/mario_actions_cutscene.c:        m->actionTimer -= headTurnAmount;
src/game/mario_actions_cutscene.c:    } else if (m->actionState == 23) {
src/game/mario_actions_cutscene.c:        if (m->flags & MARIO_CAP_IN_HAND) {
src/game/mario_actions_cutscene.c:            set_mario_action(m, m->heldObj == NULL ? ACT_IDLE : ACT_HOLD_IDLE, 0);
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioBodyState->headAngle, m->actionTimer, 0, 0);
src/game/mario_actions_cutscene.c:    if (m->actionState != 8) {
src/game/mario_actions_cutscene.c:        m->actionState++;
src/game/mario_actions_cutscene.c:                        m->heldObj == NULL ? MARIO_ANIM_FIRST_PERSON : MARIO_ANIM_IDLE_WITH_LIGHT_OBJ);
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:    if (m->actionArg) {
src/game/mario_actions_cutscene.c:        m->actionArg--;
src/game/mario_actions_cutscene.c:        if ((m->actionArg & 0xFFFF) == 0) {
src/game/mario_actions_cutscene.c:            level_trigger_warp(m, m->actionArg >> 16);
src/game/mario_actions_cutscene.c:    m->actionState++;
src/game/mario_actions_cutscene.c:    if (m->actionState == 2) {
src/game/mario_actions_cutscene.c:    if (m->actionState < 9) {
src/game/mario_actions_cutscene.c:        set_mario_animation(m, m->prevAction == ACT_STAR_DANCE_WATER ? MARIO_ANIM_WATER_IDLE
src/game/mario_actions_cutscene.c:        m->actionTimer -= 1024;
src/game/mario_actions_cutscene.c:        if (m->actionState == 9) {
src/game/mario_actions_cutscene.c:            actionArg = m->actionArg;
src/game/mario_actions_cutscene.c:        else if (m->actionState == 10) {
src/game/mario_actions_cutscene.c:                m->actionState--;
src/game/mario_actions_cutscene.c:        else if (m->actionState < 19) {
src/game/mario_actions_cutscene.c:            m->actionTimer += 1024;
src/game/mario_actions_cutscene.c:        else if (m->actionState == 25) {
src/game/mario_actions_cutscene.c:            if (m->prevAction == ACT_STAR_DANCE_WATER) {
src/game/mario_actions_cutscene.c:                set_mario_action(m, m->prevAction == ACT_UNLOCKING_STAR_DOOR ? ACT_WALKING : ACT_IDLE,
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioBodyState->headAngle, m->actionTimer, 0, 0);
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            m->actionState = 1;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] += marioObj->oMarioPoleUnk108 / 11;
src/game/mario_actions_cutscene.c:            m->pos[0] += marioObj->oMarioReadingSignDPosX / 11.0f;
src/game/mario_actions_cutscene.c:            m->pos[2] += marioObj->oMarioReadingSignDPosZ / 11.0f;
src/game/mario_actions_cutscene.c:            if (m->actionTimer++ == 10) {
src/game/mario_actions_cutscene.c:                create_dialog_inverted_box(m->usedObj->oBehParams2ndByte);
src/game/mario_actions_cutscene.c:                m->actionState = 2;
src/game/mario_actions_cutscene.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    vec3f_copy(pos, m->pos);
src/game/mario_actions_cutscene.c:    if (m->intendedMag > 0) {
src/game/mario_actions_cutscene.c:        pos[0] += 32.0f * speed * sins(m->intendedYaw);
src/game/mario_actions_cutscene.c:        pos[2] += 32.0f * speed * coss(m->intendedYaw);
src/game/mario_actions_cutscene.c:        vec3f_copy(m->pos, pos);
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->intendedYaw;
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:        if (m->pos[1] <= m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        switch (++m->actionTimer) {
src/game/mario_actions_cutscene.c:                spawn_object(m->marioObj, MODEL_STAR, bhvCelebrationStar);
src/game/mario_actions_cutscene.c:                if (m->actionArg & 1) {
src/game/mario_actions_cutscene.c:                play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                if ((m->actionArg & 1) == 0) {
src/game/mario_actions_cutscene.c:                    m->actionState = 1;
src/game/mario_actions_cutscene.c:    } else if (m->actionState == 1 && gDialogResponse) {
src/game/mario_actions_cutscene.c:        m->actionState = 2;
src/game/mario_actions_cutscene.c:    } else if (m->actionState == 2 && is_anim_at_end(m)) {
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->area->camera->yaw;
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 2 ? MARIO_ANIM_RETURN_FROM_STAR_DANCE
src/game/mario_actions_cutscene.c:    if (m->actionState != 2 && m->actionTimer >= 40) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->handState = MARIO_HAND_PEACE_SIGN;
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->area->camera->yaw;
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 2 ? MARIO_ANIM_RETURN_FROM_WATER_STAR_DANCE
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    if (m->actionState != 2 && m->actionTimer >= 62) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->handState = MARIO_HAND_PEACE_SIGN;
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 130) {
src/game/mario_actions_cutscene.c:        play_sound(SOUND_ACTION_UNKNOWN430, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->particleFlags |= PARTICLE_WATER_SPLASH;
src/game/mario_actions_cutscene.c:        return set_mario_action(m, ACT_STAR_DANCE_WATER, m->actionArg);
src/game/mario_actions_cutscene.c:        set_mario_action(m, m->actionArg & 1 ? ACT_STAR_DANCE_NO_EXIT : ACT_STAR_DANCE_EXIT,
src/game/mario_actions_cutscene.c:                         m->actionArg);
src/game/mario_actions_cutscene.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_cutscene.c:    if (m->input & INPUT_IN_POISON_GAS) {
src/game/mario_actions_cutscene.c:    if (m->marioObj->header.gfx.unk38.animFrame == 77) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (m->actionState == 1) {
src/game/mario_actions_cutscene.c:        if (m->quicksandDepth >= 100.0f) {
src/game/mario_actions_cutscene.c:        if ((m->quicksandDepth += 5.0f) >= 180.0f) {
src/game/mario_actions_cutscene.c:            m->actionState = 2;
src/game/mario_actions_cutscene.c:    play_sound(SOUND_MOVING_QUICKSAND_DEATH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:    m->health = 0xFF;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 60) {
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:    m->pos[0] = m->usedObj->oPosX + coss(m->faceAngle[1]) * 75.0f;
src/game/mario_actions_cutscene.c:    m->pos[2] = m->usedObj->oPosZ + sins(m->faceAngle[1]) * 75.0f;
src/game/mario_actions_cutscene.c:    if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    switch (m->marioObj->header.gfx.unk38.animFrame) {
src/game/mario_actions_cutscene.c:            play_sound(SOUND_GENERAL_DOOR_INSERT_KEY, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:            play_sound(SOUND_GENERAL_DOOR_TURN_KEY, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        if (m->usedObj->oBehParams >> 24 == 1) {
src/game/mario_actions_cutscene.c:    m->actionTimer++;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:            if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:                m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:            m->marioObj->oMarioReadingSignDPosX = m->pos[0];
src/game/mario_actions_cutscene.c:            m->marioObj->oMarioReadingSignDPosZ = m->pos[2];
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:                spawn_object(m->marioObj, MODEL_STAR, bhvUnlockDoorStar);
src/game/mario_actions_cutscene.c:                m->actionState++;
src/game/mario_actions_cutscene.c:            if (m->actionTimer++ == 70) {
src/game/mario_actions_cutscene.c:                m->actionState++;
src/game/mario_actions_cutscene.c:                save_file_set_flags(get_door_save_file_flag(m->usedObj));
src/game/mario_actions_cutscene.c:    m->pos[0] = m->marioObj->oMarioReadingSignDPosX;
src/game/mario_actions_cutscene.c:    m->pos[2] = m->marioObj->oMarioReadingSignDPosZ;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 0) {
src/game/mario_actions_cutscene.c:        m->interactObj->oInteractStatus = 0x00010000;
src/game/mario_actions_cutscene.c:        targetAngle = m->usedObj->oMoveAngleYaw + 0x1555;
src/game/mario_actions_cutscene.c:        if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:        targetDX = m->usedObj->oPosX + 150.0f * sins(targetAngle) - m->pos[0];
src/game/mario_actions_cutscene.c:        targetDZ = m->usedObj->oPosZ + 150.0f * coss(targetAngle) - m->pos[2];
src/game/mario_actions_cutscene.c:        m->marioObj->oMarioReadingSignDPosX = targetDX / 20.0f;
src/game/mario_actions_cutscene.c:        m->marioObj->oMarioReadingSignDPosZ = targetDZ / 20.0f;
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = atan2s(targetDZ, targetDX);
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 15) {
src/game/mario_actions_cutscene.c:    else if (m->actionTimer < 35) {
src/game/mario_actions_cutscene.c:        m->pos[0] += m->marioObj->oMarioReadingSignDPosX;
src/game/mario_actions_cutscene.c:        m->pos[2] += m->marioObj->oMarioReadingSignDPosZ;
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:        if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:        m->pos[0] += 12.0f * sins(m->faceAngle[1]);
src/game/mario_actions_cutscene.c:        m->pos[2] += 12.0f * coss(m->faceAngle[1]);
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 48) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:        if (m->actionArg & 1) {
src/game/mario_actions_cutscene.c:            m->interactObj->oInteractStatus = 0x00010000;
src/game/mario_actions_cutscene.c:            m->interactObj->oInteractStatus = 0x00020000;
src/game/mario_actions_cutscene.c:    m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_cutscene.c:    m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_cutscene.c:    m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_cutscene.c:    if (m->actionArg & 4) {
src/game/mario_actions_cutscene.c:        if (m->actionTimer == 16) {
src/game/mario_actions_cutscene.c:            if (m->actionArg & 2) {
src/game/mario_actions_cutscene.c:                m->faceAngle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->actionTimer++;
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:        if (m->actionArg & 1) {
src/game/mario_actions_cutscene.c:            m->usedObj->oInteractStatus = 0x00040000;
src/game/mario_actions_cutscene.c:            m->usedObj->oInteractStatus = 0x00080000;
src/game/mario_actions_cutscene.c:    } else if (m->usedObj->oAction == 0) {
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ < 11) {
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:    // updates all velocity variables based on m->forwardVel
src/game/mario_actions_cutscene.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_cutscene.c:    if (m->actionState == 0 && m->pos[1] - m->floorHeight > 300.0f) {
src/game/mario_actions_cutscene.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (15 < m->actionTimer++
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_GENERAL_LAND
src/game/mario_actions_cutscene.c:                m->actionState = 3; // star exit with cap
src/game/mario_actions_cutscene.c:                if (!(m->flags & MARIO_CAP_ON_HEAD)) {
src/game/mario_actions_cutscene.c:                    m->actionState = 2; // star exit without cap
src/game/mario_actions_cutscene.c:                    m->actionState = 1; // key exit
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_KEY_SWISH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_PAT_BACK, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_UNKNOWN45C, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                m->marioBodyState->handState = MARIO_HAND_OPEN;
src/game/mario_actions_cutscene.c:                m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:                    play_sound(SOUND_ACTION_BRUSH_HAIR, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    if (15 < m->actionTimer++
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ < 11) {
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:        m->actionArg = 1;
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ < 11) {
src/game/mario_actions_cutscene.c:        m->numLives--;
src/game/mario_actions_cutscene.c:        m->healCounter = 31;
src/game/mario_actions_cutscene.c:    m->health = 0x0100;
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:    cageDX = m->usedObj->oPosX - m->pos[0];
src/game/mario_actions_cutscene.c:    cageDZ = m->usedObj->oPosZ - m->pos[2];
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            floorDist = 512.0f - (m->pos[1] - m->floorHeight);
src/game/mario_actions_cutscene.c:            m->vel[1] = floorDist > 0 ? sqrtf(4.0f * floorDist + 1.0f) - 1.0f : 2.0f;
src/game/mario_actions_cutscene.c:            m->actionState = 1;
src/game/mario_actions_cutscene.c:            m->actionTimer = 100;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] = atan2s(cageDZ, cageDX);
src/game/mario_actions_cutscene.c:                play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:            m->flags &= ~MARIO_UNKNOWN_08;
src/game/mario_actions_cutscene.c:            if (m->vel[1] <= 0) {
src/game/mario_actions_cutscene.c:                m->actionState = 2;
src/game/mario_actions_cutscene.c:            m->faceAngle[1] = atan2s(cageDZ, cageDX);
src/game/mario_actions_cutscene.c:            m->flags &= ~MARIO_UNKNOWN_08;
src/game/mario_actions_cutscene.c:                m->actionState = 4;
src/game/mario_actions_cutscene.c:            if (m->actionState == 2) {
src/game/mario_actions_cutscene.c:                if (m->marioObj->header.gfx.unk38.animFrame == 0) {
src/game/mario_actions_cutscene.c:                    m->actionState = 3;
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_cutscene.c:            m->squishTimer = 0xFF;
src/game/mario_actions_cutscene.c:            if (m->actionTimer >= 11) {
src/game/mario_actions_cutscene.c:                m->actionTimer -= 6;
src/game/mario_actions_cutscene.c:                scale = m->actionTimer / 100.0f;
src/game/mario_actions_cutscene.c:                vec3f_set(m->marioObj->header.gfx.scale, scale, scale, scale);
src/game/mario_actions_cutscene.c:            m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_INVISIBLE;
src/game/mario_actions_cutscene.c:        m, m->flags & MARIO_METAL_CAP ? SOUND_ACTION_METAL_JUMP : SOUND_ACTION_TERRAIN_JUMP, 1);
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        cageDX = m->usedObj->oPosX - m->pos[0];
src/game/mario_actions_cutscene.c:        cageDZ = m->usedObj->oPosZ - m->pos[2];
src/game/mario_actions_cutscene.c:        m->vel[1] = 60.0f;
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = atan2s(cageDZ, cageDX);
src/game/mario_actions_cutscene.c:        m->flags &= ~MARIO_UNKNOWN_08;
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (m->vel[1] <= 0.0f) {
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->prevAction == ACT_CROUCHING ? MARIO_ANIM_CROUCHING
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    m->flags |= MARIO_TELEPORTING;
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 32) {
src/game/mario_actions_cutscene.c:        m->fadeWarpOpacity = (-m->actionTimer << 3) + 0xF8;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 20) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 32) {
src/game/mario_actions_cutscene.c:        m->flags |= MARIO_TELEPORTING;
src/game/mario_actions_cutscene.c:        m->fadeWarpOpacity = m->actionTimer << 3;
src/game/mario_actions_cutscene.c:        m->flags &= ~MARIO_TELEPORTING;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 32) {
src/game/mario_actions_cutscene.c:        if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:            if (m->area->camera->mode != CAMERA_MODE_WATER_SURFACE) {
src/game/mario_actions_cutscene.c:                set_camera_mode(m->area->camera, CAMERA_MODE_WATER_SURFACE, 1);
src/game/mario_actions_cutscene.c:    play_sound(SOUND_MOVING_SHOCKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->actionTimer++;
src/game/mario_actions_cutscene.c:        m->flags |= MARIO_METAL_SHOCK;
src/game/mario_actions_cutscene.c:    if (m->actionArg == 0) {
src/game/mario_actions_cutscene.c:            m->actionArg = 1;
src/game/mario_actions_cutscene.c:        if (m->actionTimer >= 6) {
src/game/mario_actions_cutscene.c:            m->invincTimer = 30;
src/game/mario_actions_cutscene.c:            set_mario_action(m, m->health < 0x0100 ? ACT_ELECTROCUTION : ACT_IDLE, 0);
src/game/mario_actions_cutscene.c:    if ((spaceUnderCeil = m->ceilHeight - m->floorHeight) < 0) {
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:                m->squishTimer = 0;
src/game/mario_actions_cutscene.c:            m->squishTimer = 0xFF;
src/game/mario_actions_cutscene.c:                vec3f_set(m->marioObj->header.gfx.scale, 2.0f - squishAmount, squishAmount,
src/game/mario_actions_cutscene.c:                if (!(m->flags & MARIO_METAL_CAP) && m->invincTimer == 0) {
src/game/mario_actions_cutscene.c:                    m->hurtCounter += m->flags & MARIO_CAP_ON_HEAD ? 12 : 18;
src/game/mario_actions_cutscene.c:                vec3f_set(m->marioObj->header.gfx.scale, 1.8, 0.05f, 1.8f);
src/game/mario_actions_cutscene.c:                m->actionState = 1;
src/game/mario_actions_cutscene.c:                m->actionState = 2;
src/game/mario_actions_cutscene.c:            m->actionTimer++;
src/game/mario_actions_cutscene.c:            if (m->actionTimer >= 15) {
src/game/mario_actions_cutscene.c:                if (m->health < 0x0100) {
src/game/mario_actions_cutscene.c:                } else if (m->hurtCounter == 0) {
src/game/mario_actions_cutscene.c:                    m->squishTimer = 30;
src/game/mario_actions_cutscene.c:    if (m->floor != NULL && m->floor->normal.y < 0.5f) {
src/game/mario_actions_cutscene.c:        surfAngle = atan2s(m->floor->normal.z, m->floor->normal.x);
src/game/mario_actions_cutscene.c:    if (m->ceil != NULL && -0.5f < m->ceil->normal.y) {
src/game/mario_actions_cutscene.c:        surfAngle = atan2s(m->ceil->normal.z, m->ceil->normal.x);
src/game/mario_actions_cutscene.c:        m->vel[0] = sins(surfAngle) * 10.0f;
src/game/mario_actions_cutscene.c:        m->vel[2] = coss(surfAngle) * 10.0f;
src/game/mario_actions_cutscene.c:        m->vel[1] = 0;
src/game/mario_actions_cutscene.c:            m->squishTimer = 0;
src/game/mario_actions_cutscene.c:    if (m->actionArg++ > 300) {
src/game/mario_actions_cutscene.c:        m->health = 0x00FF;
src/game/mario_actions_cutscene.c:        m->hurtCounter = 0;
src/game/mario_actions_cutscene.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_cutscene.c:        m->actionTimer++;
src/game/mario_actions_cutscene.c:        if (m->actionTimer >= 5 && animFrame < unstuckFrame - 1) {
src/game/mario_actions_cutscene.c:    m->actionState = 0;
src/game/mario_actions_cutscene.c:    m->actionTimer = 0;
src/game/mario_actions_cutscene.c:    m->actionArg++;
src/game/mario_actions_cutscene.c:    m->statusForCamera->cameraEvent = CAM_EVENT_START_INTRO;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:    if ((s16) m->statusForCamera->cameraEvent != CAM_EVENT_START_INTRO) {
src/game/mario_actions_cutscene.c:        if (m->actionTimer++ == TIMER_SPAWN_PIPE) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 0) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == TIMER_RAISE_PIPE) {
src/game/mario_actions_cutscene.c:        m->vel[1] = 60.0f;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 25) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ >= 118) {
src/game/mario_actions_cutscene.c:        m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
src/game/mario_actions_cutscene.c:            play_sound(SOUND_MARIO_HAHA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 0) {
src/game/mario_actions_cutscene.c:    switch (m->actionArg) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->input |= INPUT_A_DOWN;
src/game/mario_actions_cutscene.c:        m->flags |= (MARIO_WING_CAP | MARIO_CAP_ON_HEAD);
src/game/mario_actions_cutscene.c:        m->faceAngle[1] = -0x8000;
src/game/mario_actions_cutscene.c:        m->pos[0] = 0.0f;
src/game/mario_actions_cutscene.c:        m->pos[2] = 0.0f;
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:            m->statusForCamera->cameraEvent = CAM_EVENT_START_GRAND_STAR;
src/game/mario_actions_cutscene.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:                           m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                play_sound(SOUND_MARIO_HOOHOO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:                play_sound(SOUND_MARIO_YAHOO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    vec3f_set(m->pos, 0.0f, 307.0, marioObj->rawData.asF32[0x22]);
src/game/mario_actions_cutscene.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    vec3s_set(marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_cutscene.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_cutscene.c:    switch (m->actionState) {
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:                m->actionState++;
src/game/mario_actions_cutscene.c:                targetDX = targetPos[0] - m->pos[0];
src/game/mario_actions_cutscene.c:                targetDY = targetPos[1] - m->pos[1];
src/game/mario_actions_cutscene.c:                targetDZ = targetPos[2] - m->pos[2];
src/game/mario_actions_cutscene.c:                vec3f_copy(m->pos, targetPos);
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[0] = -atan2s(targetHyp, targetDY);
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[1] = targetAngle;
src/game/mario_actions_cutscene.c:                m->marioObj->header.gfx.angle[2] = ((m->faceAngle[1] - targetAngle) << 16 >> 16) * 20;
src/game/mario_actions_cutscene.c:                m->faceAngle[1] = targetAngle;
src/game/mario_actions_cutscene.c:    m->marioBodyState->handState = MARIO_HAND_RIGHT_OPEN;
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 500) {
src/game/mario_actions_cutscene.c:    switch (m->actionArg) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 1) {
src/game/mario_actions_cutscene.c:        m->statusForCamera->cameraEvent = CAM_EVENT_START_ENDING;
src/game/mario_actions_cutscene.c:    m->input |= INPUT_A_DOWN;
src/game/mario_actions_cutscene.c:    m->flags |= (MARIO_WING_CAP | MARIO_CAP_ON_HEAD);
src/game/mario_actions_cutscene.c:        m->capTimer = 60;
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 0 ? MARIO_ANIM_CREDITS_RAISE_HAND
src/game/mario_actions_cutscene.c:    if (m->actionState == 0 && is_anim_past_end(m)) {
src/game/mario_actions_cutscene.c:        m->actionState++;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 90) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 255) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 1) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 2) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 44) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 40) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_FADE_IN_PEACH) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= 40) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == TIMER_DESCEND_PEACH) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= 40) {
src/game/mario_actions_cutscene.c:        if (m->actionState < 60) {
src/game/mario_actions_cutscene.c:            m->actionState += 5;
src/game/mario_actions_cutscene.c:        if (m->actionState >= 27) {
src/game/mario_actions_cutscene.c:            m->actionState -= 2;
src/game/mario_actions_cutscene.c:    if ((sEndPeachObj->oPosY -= m->actionState / 10) <= 907.0f) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_RUN_TO_PEACH) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 22) {
src/game/mario_actions_cutscene.c:    if ((m->pos[2] -= 20.0f) <= -1181.0f) {
src/game/mario_actions_cutscene.c:        m->pos[2] = -1180.0f;
src/game/mario_actions_cutscene.c:    m->pos[1] = find_surface_down(m->pos[0], m->pos[1], m->pos[2], &surf);
src/game/mario_actions_cutscene.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:    m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_cutscene.c:    s32 animFrame = set_mario_animation(m, m->actionState == 0 ? MARIO_ANIM_CREDITS_TAKE_OFF_CAP
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:            m->actionState++;
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= 90) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->eyeState =
src/game/mario_actions_cutscene.c:            m->actionTimer < 110 ? sMarioBlinkOverride[m->actionTimer - 90] : MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:            m->marioBodyState->eyeState = MARIO_EYES_CLOSED;
src/game/mario_actions_cutscene.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_cutscene.c:        m->marioBodyState->handState = MARIO_HAND_PEACE_SIGN;
src/game/mario_actions_cutscene.c:    if (m->actionTimer < 52) {
src/game/mario_actions_cutscene.c:        m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    switch (m->actionTimer) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 350) {
src/game/mario_actions_cutscene.c:    set_mario_animation(m, m->actionState == 0 ? MARIO_ANIM_CREDITS_START_WALK_LOOK_UP
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.pos[1] = end_obj_set_visual_pos(m->marioObj);
src/game/mario_actions_cutscene.c:    if (m->actionState == 0 && is_anim_past_end(m)) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 95) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer == 389) {
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    switch (m->actionArg) {
src/game/mario_actions_cutscene.c:    m->actionTimer++;
src/game/mario_actions_cutscene.c:    m->statusForCamera->cameraEvent = CAM_EVENT_START_CREDITS;
src/game/mario_actions_cutscene.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_cutscene.c:        if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_cutscene.c:            set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario_actions_cutscene.c:        vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_cutscene.c:        vec3s_copy(m->marioObj->header.gfx.angle, m->faceAngle);
src/game/mario_actions_cutscene.c:        m->particleFlags |= PARTICLE_BUBBLE;
src/game/mario_actions_cutscene.c:        if (m->actionTimer > 0) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_CREDITS_SHOW) {
src/game/mario_actions_cutscene.c:        if (m->actionState < 40) {
src/game/mario_actions_cutscene.c:            m->actionState += 2;
src/game/mario_actions_cutscene.c:        width = m->actionState * 640 / 100;
src/game/mario_actions_cutscene.c:        height = m->actionState * 480 / 100;
src/game/mario_actions_cutscene.c:    if (m->actionTimer == TIMER_CREDITS_PROGRESS) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer >= TIMER_CREDITS_PROGRESS) {
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == TIMER_CREDITS_WARP) {
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += (gCurrCreditsEntry->unk02 & 0xC0) << 8;
src/game/mario_actions_cutscene.c:    if (m->actionState == 0) {
src/game/mario_actions_cutscene.c:        m->statusForCamera->cameraEvent = CAM_EVENT_START_END_WAVING;
src/game/mario_actions_cutscene.c:        m->actionState = 1;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_cutscene.c:    m->marioObj->header.gfx.pos[0] -= 60.0f;
src/game/mario_actions_cutscene.c:    m->marioBodyState->handState = MARIO_HAND_RIGHT_OPEN;
src/game/mario_actions_cutscene.c:    if (m->actionTimer++ == 300) {
src/game/mario_actions_cutscene.c:    if (m->floor->type == SURFACE_INSTANT_QUICKSAND && m->action & ACT_FLAG_INVULNERABLE
src/game/mario_actions_cutscene.c:        && m->action != ACT_QUICKSAND_DEATH) {
src/game/mario_actions_cutscene.c:    switch (m->action) {
src/game/mario_actions_cutscene.c:        if (m->input & INPUT_IN_WATER) {
src/game/mario_actions_cutscene.c:            m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_moving.c:    pitch = pitch * m->forwardVel / 40.0f;
src/game/mario_actions_moving.c:        if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_moving.c:            if (m->marioObj->header.gfx.unk38.animID == MARIO_ANIM_TIPTOE) {
src/game/mario_actions_moving.c:        } else if (m->quicksandDepth > 50.0f) {
src/game/mario_actions_moving.c:            play_sound(SOUND_ACTION_QUICKSAND_STEP, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        } else if (m->marioObj->header.gfx.unk38.animID == MARIO_ANIM_TIPTOE) {
src/game/mario_actions_moving.c:    m->pos[1] = m->floorHeight;
src/game/mario_actions_moving.c:    mtxf_align_terrain_triangle(D_80339F50[m->unk00], m->pos, m->faceAngle[1], 40.0f);
src/game/mario_actions_moving.c:    m->marioObj->header.gfx.throwMatrix = &D_80339F50[m->unk00];
src/game/mario_actions_moving.c:    m->faceAngle[1] = m->intendedYaw;
src/game/mario_actions_moving.c:    if (m->forwardVel < 10.0f) {
src/game/mario_actions_moving.c:        wallCols.x = m->pos[0];
src/game/mario_actions_moving.c:        wallCols.y = m->pos[1];
src/game/mario_actions_moving.c:        wallCols.z = m->pos[2];
src/game/mario_actions_moving.c:                    wallDYaw = wallAngle - m->faceAngle[1];
src/game/mario_actions_moving.c:                        m->pos[0] = wallCols.x - 20.0f * wall->normal.x;
src/game/mario_actions_moving.c:                        m->pos[2] = wallCols.z - 20.0f * wall->normal.z;
src/game/mario_actions_moving.c:                        m->faceAngle[0] = 0;
src/game/mario_actions_moving.c:                        m->faceAngle[1] = wallAngle + 0x8000;
src/game/mario_actions_moving.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:    if (m->flags & MARIO_WING_CAP) {
src/game/mario_actions_moving.c:    } else if (m->forwardVel > 20.0f) {
src/game/mario_actions_moving.c:    struct Surface *floor = m->floor;
src/game/mario_actions_moving.c:    m->slideVelX += accel * steepness * sins(slopeAngle);
src/game/mario_actions_moving.c:    m->slideVelZ += accel * steepness * coss(slopeAngle);
src/game/mario_actions_moving.c:    m->slideVelX *= lossFactor;
src/game/mario_actions_moving.c:    m->slideVelZ *= lossFactor;
src/game/mario_actions_moving.c:    m->slideYaw = atan2s(m->slideVelZ, m->slideVelX);
src/game/mario_actions_moving.c:    facingDYaw = m->faceAngle[1] - m->slideYaw;
src/game/mario_actions_moving.c:    m->faceAngle[1] = m->slideYaw + newFacingDYaw;
src/game/mario_actions_moving.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_moving.c:    m->vel[1] = 0.0f;
src/game/mario_actions_moving.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_moving.c:    m->forwardVel = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:    if (m->forwardVel > 100.0f) {
src/game/mario_actions_moving.c:        m->slideVelX = m->slideVelX * 100.0f / m->forwardVel;
src/game/mario_actions_moving.c:        m->slideVelZ = m->slideVelZ * 100.0f / m->forwardVel;
src/game/mario_actions_moving.c:        m->forwardVel *= -1.0f;
src/game/mario_actions_moving.c:    s16 intendedDYaw = m->intendedYaw - m->slideYaw;
src/game/mario_actions_moving.c:    if (forward < 0.0f && m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        forward *= 0.5f + 0.5f * m->forwardVel / 100.0f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.98f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.96f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
src/game/mario_actions_moving.c:            lossFactor = m->intendedMag / 32.0f * forward * 0.02f + 0.92f;
src/game/mario_actions_moving.c:    oldSpeed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:    m->slideVelX += m->slideVelZ * (m->intendedMag / 32.0f) * sideward * 0.05f;
src/game/mario_actions_moving.c:    m->slideVelZ -= m->slideVelX * (m->intendedMag / 32.0f) * sideward * 0.05f;
src/game/mario_actions_moving.c:    newSpeed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:        m->slideVelX = m->slideVelX * oldSpeed / newSpeed;
src/game/mario_actions_moving.c:        m->slideVelZ = m->slideVelZ * oldSpeed / newSpeed;
src/game/mario_actions_moving.c:    if (!mario_floor_is_slope(m) && m->forwardVel * m->forwardVel < stopSpeed * stopSpeed) {
src/game/mario_actions_moving.c:    struct Surface *floor = m->floor;
src/game/mario_actions_moving.c:    s16 floorDYaw = m->floorAngle - m->faceAngle[1];
src/game/mario_actions_moving.c:        if (m->action != ACT_SOFT_BACKWARD_GROUND_KB && m->action != ACT_SOFT_FORWARD_GROUND_KB) {
src/game/mario_actions_moving.c:            m->forwardVel += slopeAccel * steepness;
src/game/mario_actions_moving.c:            m->forwardVel -= slopeAccel * steepness;
src/game/mario_actions_moving.c:    m->slideYaw = m->faceAngle[1];
src/game/mario_actions_moving.c:    m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_moving.c:    m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_moving.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_moving.c:    m->vel[1] = 0.0f;
src/game/mario_actions_moving.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_moving.c:        m->forwardVel *= frictionFactor;
src/game/mario_actions_moving.c:        if (m->forwardVel * m->forwardVel < 1.0f) {
src/game/mario_actions_moving.c:    if (m->floorHeight < m->waterLevel) {
src/game/mario_actions_moving.c:        m->floorHeight = m->waterLevel;
src/game/mario_actions_moving.c:        m->floor = &gWaterSurfacePseudoFloor;
src/game/mario_actions_moving.c:        m->floor->originOffset = m->waterLevel; //! Negative origin offset
src/game/mario_actions_moving.c:    if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
src/game/mario_actions_moving.c:    targetSpeed = m->intendedMag * 2.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel <= 0.0f) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f;
src/game/mario_actions_moving.c:    } else if (m->forwardVel <= targetSpeed) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f - m->forwardVel / 58.0f;
src/game/mario_actions_moving.c:    } else if (m->floor->normal.y >= 0.95f) {
src/game/mario_actions_moving.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel > 64.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 64.0f;
src/game/mario_actions_moving.c:    m->faceAngle[1] =
src/game/mario_actions_moving.c:        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_moving.c:    if ((m->forwardVel = approach_f32(m->forwardVel, 0.0f, decel, decel)) == 0.0f) {
src/game/mario_actions_moving.c:    if ((m->forwardVel = approach_f32(m->forwardVel, 0.0f, 1.0f, 1.0f)) == 0.0f) {
src/game/mario_actions_moving.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_moving.c:    if (m->floor != NULL && m->floor->type == SURFACE_SLOW) {
src/game/mario_actions_moving.c:    targetSpeed = m->intendedMag < maxTargetSpeed ? m->intendedMag : maxTargetSpeed;
src/game/mario_actions_moving.c:    if (m->quicksandDepth > 10.0f) {
src/game/mario_actions_moving.c:        targetSpeed *= 6.25 / m->quicksandDepth;
src/game/mario_actions_moving.c:    if (m->forwardVel <= 0.0f) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f;
src/game/mario_actions_moving.c:    } else if (m->forwardVel <= targetSpeed) {
src/game/mario_actions_moving.c:        m->forwardVel += 1.1f - m->forwardVel / 43.0f;
src/game/mario_actions_moving.c:    } else if (m->floor->normal.y >= 0.95f) {
src/game/mario_actions_moving.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel > 48.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 48.0f;
src/game/mario_actions_moving.c:    m->faceAngle[1] =
src/game/mario_actions_moving.c:        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:        s32 slideLevel = (m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE;
src/game/mario_actions_moving.c:        s32 movingBackward = m->forwardVel <= -1.0f;
src/game/mario_actions_moving.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:        if (m->forwardVel >= 29.0f && m->controller->stickMag > 48.0f) {
src/game/mario_actions_moving.c:            m->vel[1] = 20.0f;
src/game/mario_actions_moving.c:    if (m->actionState == 1) {
src/game/mario_actions_moving.c:        m->faceAngle[1] = m->actionArg;
src/game/mario_actions_moving.c:    if (m->forwardVel >= 16.0f && m->floor->normal.y >= 0.17364818f) {
src/game/mario_actions_moving.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_moving.c:    val04 = m->intendedMag > m->forwardVel ? m->intendedMag : m->forwardVel;
src/game/mario_actions_moving.c:    if (m->quicksandDepth > 50.0f) {
src/game/mario_actions_moving.c:        m->actionTimer = 0;
src/game/mario_actions_moving.c:            switch (m->actionTimer) {
src/game/mario_actions_moving.c:                        m->actionTimer = 2;
src/game/mario_actions_moving.c:                            m->actionTimer = 2;
src/game/mario_actions_moving.c:                        m->actionTimer = 2;
src/game/mario_actions_moving.c:                        m->actionTimer = 1;
src/game/mario_actions_moving.c:                        m->actionTimer = 3;
src/game/mario_actions_moving.c:                        m->actionTimer = 2;
src/game/mario_actions_moving.c:    val04 = m->intendedMag > m->forwardVel ? m->intendedMag : m->forwardVel;
src/game/mario_actions_moving.c:        switch (m->actionTimer) {
src/game/mario_actions_moving.c:                    m->actionTimer = 1;
src/game/mario_actions_moving.c:                    m->actionTimer = 0;
src/game/mario_actions_moving.c:                    m->actionTimer = 2;
src/game/mario_actions_moving.c:                    m->actionTimer = 1;
src/game/mario_actions_moving.c:    s32 val04 = (s32)(m->intendedMag * 0x10000);
src/game/mario_actions_moving.c:    f32 dx = m->pos[0] - startPos[0];
src/game/mario_actions_moving.c:    f32 dz = m->pos[2] - startPos[2];
src/game/mario_actions_moving.c:    if (m->forwardVel > 6.0f) {
src/game/mario_actions_moving.c:    if (m->wall != NULL) {
src/game/mario_actions_moving.c:        wallAngle = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_actions_moving.c:        dWallAngle = wallAngle - m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->wall == NULL || dWallAngle <= -0x71C8 || dWallAngle >= 0x71C8) {
src/game/mario_actions_moving.c:        m->flags |= MARIO_UNKNOWN_31;
src/game/mario_actions_moving.c:        if (m->marioObj->header.gfx.unk38.animFrame < 20) {
src/game/mario_actions_moving.c:            play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:        m->actionState = 1;
src/game/mario_actions_moving.c:        m->actionArg = wallAngle + 0x8000;
src/game/mario_actions_moving.c:        m->marioObj->header.gfx.angle[1] = wallAngle + 0x8000;
src/game/mario_actions_moving.c:        m->marioObj->header.gfx.angle[2] = find_floor_slope(m, 0x4000);
src/game/mario_actions_moving.c:    struct MarioBodyState *val0C = m->marioBodyState;
src/game/mario_actions_moving.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_moving.c:    s16 animID = m->marioObj->header.gfx.unk38.animID;
src/game/mario_actions_moving.c:        dYaw = m->faceAngle[1] - startYaw;
src/game/mario_actions_moving.c:        val02 = -(s16)(dYaw * m->forwardVel / 12.0f);
src/game/mario_actions_moving.c:        val00 = (s16)(m->forwardVel * 170.0f);
src/game/mario_actions_moving.c:    struct MarioBodyState *val0C = m->marioBodyState;
src/game/mario_actions_moving.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_moving.c:    s16 dYaw = m->faceAngle[1] - startYaw;
src/game/mario_actions_moving.c:    s16 val04 = -(s16)(dYaw * m->forwardVel / 12.0f);
src/game/mario_actions_moving.c:    s16 val02 = (s16)(m->forwardVel * 170.0f);
src/game/mario_actions_moving.c:    s16 startYaw = m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    if (analog_stick_held_back(m) && m->forwardVel >= 16.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:    m->actionState = 0;
src/game/mario_actions_moving.c:    vec3f_copy(startPos, m->pos);
src/game/mario_actions_moving.c:            if (m->intendedMag - m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:                m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:            m->actionTimer = 0;
src/game/mario_actions_moving.c:    if (m->actionState == 0 && (m->input & INPUT_A_DOWN)) {
src/game/mario_actions_moving.c:    m->actionState = 1;
src/game/mario_actions_moving.c:    if (m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        if ((m->forwardVel += 8.0f) >= 0.0f) {
src/game/mario_actions_moving.c:            m->forwardVel = 0.0f;
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->heldObj->behavior == segmented_to_virtual(bhvJumpingBox)) {
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.4f;
src/game/mario_actions_moving.c:            if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:    if (0.4f * m->intendedMag - m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.1f;
src/game/mario_actions_moving.c:            if (m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->forwardVel >= 18.0f) {
src/game/mario_actions_moving.c:            if (m->forwardVel > 0.0f) {
src/game/mario_actions_moving.c:                begin_walking_action(m, -m->forwardVel, ACT_WALKING, 0);
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_FIRST_PERSON)
src/game/mario_actions_moving.c:        && (m->input
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_FIRST_PERSON)) {
src/game/mario_actions_moving.c:        if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:        if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:        if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:        if ((val0C = (s32)(m->forwardVel / 4.0f * 0x10000)) < 0x1000) {
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.4f;
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:        if ((val0C = (s32)(m->forwardVel * 0x10000)) < 0x1000) {
src/game/mario_actions_moving.c:    /*06*/ s16 startYaw = m->faceAngle[1];
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_moving.c:        if (m->forwardVel < 24.0f) {
src/game/mario_actions_moving.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_START_RIDING_SHELL : MARIO_ANIM_RIDING_SHELL);
src/game/mario_actions_moving.c:            play_sound(m->flags & MARIO_METAL_CAP ? SOUND_ACTION_METAL_BONK : SOUND_ACTION_BONK,
src/game/mario_actions_moving.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:    if (m->floor->type == SURFACE_BURNING) {
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_RIDING_SHELL_LAVA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:        play_sound(SOUND_MOVING_TERRAIN_RIDING_SHELL + m->terrainSoundAddend,
src/game/mario_actions_moving.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_moving.c:    m->intendedMag *= 0.1f;
src/game/mario_actions_moving.c:            if (m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:    val04 = (s32)(m->intendedMag * 2.0f * 0x10000);
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    m->marioObj->oMarioBurnTimer += 2;
src/game/mario_actions_moving.c:    if (m->marioObj->oMarioBurnTimer > 160) {
src/game/mario_actions_moving.c:    if (m->waterLevel - m->floorHeight > 50.0f) {
src/game/mario_actions_moving.c:        play_sound(SOUND_GENERAL_FLAME_OUT, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (m->forwardVel < 8.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 8.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel > 48.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 48.0f;
src/game/mario_actions_moving.c:    m->forwardVel = approach_f32(m->forwardVel, 32.0f, 4.0f, 1.0f);
src/game/mario_actions_moving.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:        m->faceAngle[1] =
src/game/mario_actions_moving.c:            m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x600, 0x600);
src/game/mario_actions_moving.c:    set_mario_anim_with_accel(m, MARIO_ANIM_RUNNING, (s32)(m->forwardVel / 2.0f * 0x10000));
src/game/mario_actions_moving.c:    m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    m->health -= 10;
src/game/mario_actions_moving.c:    if (m->health < 0x100) {
src/game/mario_actions_moving.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_moving.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_moving.c:    m->marioBodyState->torsoAngle[0] = (s32)(5461.3335f * m->intendedMag / 32.0f * coss(intendedDYaw));
src/game/mario_actions_moving.c:    m->marioBodyState->torsoAngle[2] = (s32)(-(5461.3335f * m->intendedMag / 32.0f * sins(intendedDYaw)));
src/game/mario_actions_moving.c:    vec3f_copy(val14, m->pos);
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            if (m->forwardVel < -50.0f || 50.0f < m->forwardVel) {
src/game/mario_actions_moving.c:                play_sound(SOUND_MARIO_HOOHOO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:                m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:                if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:                    m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:            } else if (m->wall != NULL) {
src/game/mario_actions_moving.c:                s16 wallAngle = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_actions_moving.c:                f32 slideSpeed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_moving.c:                m->slideYaw = wallAngle - (s16)(m->slideYaw - wallAngle) + 0x8000;
src/game/mario_actions_moving.c:                m->vel[0] = m->slideVelX = slideSpeed * sins(m->slideYaw);
src/game/mario_actions_moving.c:                m->vel[2] = m->slideVelZ = slideSpeed * coss(m->slideYaw);
src/game/mario_actions_moving.c:    if (m->actionTimer == 5) {
src/game/mario_actions_moving.c:        if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:        m->actionTimer++;
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_moving.c:    if (m->actionTimer < 30) {
src/game/mario_actions_moving.c:        m->actionTimer++;
src/game/mario_actions_moving.c:        if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:            if (m->forwardVel > 10.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_moving.c:        if (m->forwardVel >= 10.0f) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (is_anim_at_end(m) && m->forwardVel < 1.0f) {
src/game/mario_actions_moving.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_moving.c:    play_sound(SOUND_MOVING_TERRAIN_SLIDE + m->terrainSoundAddend, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->actionTimer == 5) {
src/game/mario_actions_moving.c:        if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
src/game/mario_actions_moving.c:                m, m->forwardVel >= 0.0f ? ACT_FORWARD_ROLLOUT : ACT_BACKWARD_ROLLOUT, 0);
src/game/mario_actions_moving.c:        m->actionTimer++;
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_ABOVE_SLIDE) && (m->input & (INPUT_A_PRESSED | INPUT_B_PRESSED))) {
src/game/mario_actions_moving.c:        return set_mario_action(m, m->forwardVel > 0.0f ? ACT_FORWARD_ROLLOUT : ACT_BACKWARD_ROLLOUT,
src/game/mario_actions_moving.c:        m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_moving.c:    if (m->forwardVel > 32.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 32.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel < -32.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = -32.0f;
src/game/mario_actions_moving.c:    } else if (m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        if (m->forwardVel >= 0.0f) {
src/game/mario_actions_moving.c:        if (m->health < 0x100) {
src/game/mario_actions_moving.c:                m->invincTimer = 30;
src/game/mario_actions_moving.c:        common_ground_knockback_action(m, MARIO_ANIM_FALL_OVER_BACKWARDS, 0x2B, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    if (val04 == 0x2B && m->health < 0x100) {
src/game/mario_actions_moving.c:    if (val04 == 0x36 && m->prevAction == ACT_SPECIAL_DEATH_EXIT) {
src/game/mario_actions_moving.c:        play_sound(SOUND_MARIO_MAMA_MIA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    s32 val04 = common_ground_knockback_action(m, MARIO_ANIM_LAND_ON_STOMACH, 0x15, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    if (val04 == 0x17 && m->health < 0x100) {
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_BACKWARD_KB, 0x16, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_FORWARD_KB, 0x14, TRUE, m->actionArg);
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_SOFT_BACK_KB, 0x64, FALSE, m->actionArg);
src/game/mario_actions_moving.c:    common_ground_knockback_action(m, MARIO_ANIM_SOFT_FRONT_KB, 0x64, FALSE, m->actionArg);
src/game/mario_actions_moving.c:    s32 val04 = common_ground_knockback_action(m, MARIO_ANIM_GROUND_BONK, 0x20, TRUE, m->actionArg);
src/game/mario_actions_moving.c:        play_sound(SOUND_MARIO_MAMA_MIA, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_moving.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_moving.c:    } else if (m->forwardVel >= 16.0f) {
src/game/mario_actions_moving.c:        m->vel[1] = 0.0f;
src/game/mario_actions_moving.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_moving.c:    if (m->floor->type >= SURFACE_SHALLOW_QUICKSAND && m->floor->type <= SURFACE_MOVING_QUICKSAND) {
src/game/mario_actions_moving.c:        m->quicksandDepth += (4 - m->actionTimer) * 3.5f - 0.5f;
src/game/mario_actions_moving.c:    if (m->floor->normal.y < 0.2923717f) {
src/game/mario_actions_moving.c:    m->doubleJumpTimer = landingAction->unk02;
src/game/mario_actions_moving.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_moving.c:    if (++m->actionTimer >= landingAction->numFrames) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_moving.c:        m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_moving.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_moving.c:        m->forwardVel = 0.0f;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_moving.c:        m->input &= ~INPUT_A_PRESSED;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_moving.c:                          !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
src/game/mario_actions_moving.c:    m->input &= ~INPUT_A_PRESSED;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_moving.c:        m->input &= ~INPUT_A_PRESSED;
src/game/mario_actions_moving.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_moving.c:    if (m->actionTimer++ < 6) {
src/game/mario_actions_moving.c:        m->quicksandDepth -= (7 - m->actionTimer) * 0.8f;
src/game/mario_actions_moving.c:        if (m->quicksandDepth < 1.0f) {
src/game/mario_actions_moving.c:            m->quicksandDepth = 1.1f;
src/game/mario_actions_moving.c:        if (m->actionTimer >= 13) {
src/game/mario_actions_moving.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_moving.c:    if (!(m->action & ACT_FLAG_INVULNERABLE) && (m->input & INPUT_UNKNOWN_10)) {
src/game/mario_actions_moving.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_moving.c:    if (!(m->action & ACT_FLAG_INVULNERABLE)) {
src/game/mario_actions_moving.c:        if (m->health < 0x100) {
src/game/mario_actions_moving.c:    switch (m->action) {
src/game/mario_actions_moving.c:    if (!cancel && (m->input & INPUT_IN_WATER)) {
src/game/mario_actions_moving.c:        m->particleFlags |= PARTICLE_WAVE_TRAIL;
src/game/mario_actions_moving.c:        m->particleFlags &= ~PARTICLE_DUST;
src/game/platform_displacement.c:    rotation[0] = platform->oAngleVelPitch;
src/game/platform_displacement.c:    rotation[1] = platform->oAngleVelYaw;
src/game/platform_displacement.c:    rotation[2] = platform->oAngleVelRoll;
src/game/platform_displacement.c:    x += platform->oVelX;
src/game/platform_displacement.c:    z += platform->oVelZ;
src/game/platform_displacement.c:        unused3 = platform->oFaceAngleYaw;
src/game/platform_displacement.c:        platformPosX = platform->oPosX;
src/game/platform_displacement.c:        platformPosY = platform->oPosY;
src/game/platform_displacement.c:        platformPosZ = platform->oPosZ;
src/game/platform_displacement.c:        rotation[0] = platform->oFaceAnglePitch - platform->oAngleVelPitch;
src/game/platform_displacement.c:        rotation[1] = platform->oFaceAngleYaw - platform->oAngleVelYaw;
src/game/platform_displacement.c:        rotation[2] = platform->oFaceAngleRoll - platform->oAngleVelRoll;
src/game/platform_displacement.c:        rotation[0] = platform->oFaceAnglePitch;
src/game/platform_displacement.c:        rotation[1] = platform->oFaceAngleYaw;
src/game/platform_displacement.c:        rotation[2] = platform->oFaceAngleRoll;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    return (o->header.gfx.unk38.animFrame + 1) == o->header.gfx.unk38.curAnim->unk08;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    return o->header.gfx.unk38.animFrame >= (o->header.gfx.unk38.curAnim->unk08 - 2);
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    struct Animation *targetAnim = m->animation->targetAnim;
src/game/mario.c:    if (load_patchable_table(m->animation, targetAnimID)) {
src/game/mario.c:        targetAnim->values = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->values);
src/game/mario.c:        targetAnim->index = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->index);
src/game/mario.c:        o->header.gfx.unk38.animYTrans = m->unkB0;
src/game/mario.c:        if (targetAnim->flags & ANIM_FLAG_2) {
src/game/mario.c:            o->header.gfx.unk38.animFrame = targetAnim->unk04;
src/game/mario.c:            if (targetAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:                o->header.gfx.unk38.animFrame = targetAnim->unk04 + 1;
src/game/mario.c:                o->header.gfx.unk38.animFrame = targetAnim->unk04 - 1;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:    struct Animation *targetAnim = m->animation->targetAnim;
src/game/mario.c:    if (load_patchable_table(m->animation, targetAnimID)) {
src/game/mario.c:        targetAnim->values = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->values);
src/game/mario.c:        targetAnim->index = (void *) VIRTUAL_TO_PHYSICAL((u8 *) targetAnim + (uintptr_t) targetAnim->index);
src/game/mario.c:        o->header.gfx.unk38.animYTrans = m->unkB0;
src/game/mario.c:        if (targetAnim->flags & ANIM_FLAG_2) {
src/game/mario.c:            o->header.gfx.unk38.animFrameAccelAssist = (targetAnim->unk04 << 0x10);
src/game/mario.c:            if (targetAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:                o->header.gfx.unk38.animFrameAccelAssist = (targetAnim->unk04 << 0x10) + accel;
src/game/mario.c:                o->header.gfx.unk38.animFrameAccelAssist = (targetAnim->unk04 << 0x10) - accel;
src/game/mario.c:    struct GraphNodeObject_sub *animInfo = &m->marioObj->header.gfx.unk38;
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:    struct GraphNodeObject_sub *animInfo = &m->marioObj->header.gfx.unk38;
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:        if (curAnim->flags & ANIM_FLAG_FORWARD) {
src/game/mario.c:    u16 *animIndex = segmented_to_virtual((void *) curAnim->index);
src/game/mario.c:    s16 *animValues = segmented_to_virtual((void *) curAnim->values);
src/game/mario.c:    return curAnim->flags;
src/game/mario.c:    flags = find_mario_anim_flags_and_translation(m->marioObj, m->faceAngle[1], translation);
src/game/mario.c:        m->pos[0] += (f32) translation[0];
src/game/mario.c:        m->pos[2] += (f32) translation[2];
src/game/mario.c:        m->pos[1] += (f32) translation[1];
src/game/mario.c:    find_mario_anim_flags_and_translation(m->marioObj, 0, translation);
src/game/mario.c:    if ((m->flags & flags) == 0) {
src/game/mario.c:        play_sound(soundBits, m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:        m->flags |= flags;
src/game/mario.c:    if (!(m->flags & MARIO_MARIO_SOUND_PLAYED)) {
src/game/mario.c:        if (m->action == ACT_TRIPLE_JUMP) {
src/game/mario.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:        m->flags |= MARIO_MARIO_SOUND_PLAYED;
src/game/mario.c:    s32 absForwardVel = (m->forwardVel > 0.0f) ? m->forwardVel : -m->forwardVel;
src/game/mario.c:    if (m->terrainSoundAddend == (SOUND_TERRAIN_WATER << 16)) {
src/game/mario.c:            m->particleFlags |= PARTICLE_SHALLOW_WATER_SPLASH;
src/game/mario.c:            m->particleFlags |= PARTICLE_SHALLOW_WATER_WAVE;
src/game/mario.c:        if (m->terrainSoundAddend == (SOUND_TERRAIN_SAND << 16)) {
src/game/mario.c:            m->particleFlags |= PARTICLE_DIRT;
src/game/mario.c:        } else if (m->terrainSoundAddend == (SOUND_TERRAIN_SNOW << 16)) {
src/game/mario.c:            m->particleFlags |= PARTICLE_SNOW;
src/game/mario.c:    if ((m->flags & MARIO_METAL_CAP) || soundBits == SOUND_ACTION_UNSTUCK_FROM_GROUND
src/game/mario.c:        play_sound(soundBits, m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:        play_sound(m->terrainSoundAddend + soundBits, m->marioObj->header.gfx.cameraToObject);
src/game/mario.c:    if ((m->flags & MARIO_ACTION_SOUND_PLAYED) == 0) {
src/game/mario.c:        m->flags |= MARIO_ACTION_SOUND_PLAYED;
src/game/mario.c:        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_LANDING : soundBits, 1);
src/game/mario.c:    play_mario_action_sound(m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_LANDING : soundBits,
src/game/mario.c:        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_HEAVY_LANDING : soundBits, 1);
src/game/mario.c:        m, (m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_HEAVY_LANDING : soundBits, 1);
src/game/mario.c:                m, (m->flags & MARIO_METAL_CAP) ? (s32)SOUND_ACTION_METAL_JUMP
src/game/mario.c:    m->forwardVel = forwardVel;
src/game/mario.c:        m->slideVelX = sins(m->faceAngle[1]) * m->forwardVel;
src/game/mario.c:        m->slideVelZ = coss(m->faceAngle[1]) * m->forwardVel;
src/game/mario.c:        m->slideVelX = -sins(m->faceAngle[1]) * m->forwardVel;
src/game/mario.c:        m->slideVelZ = -coss(m->faceAngle[1]) * m->forwardVel;
src/game/mario.c:    m->vel[0] = (f32) m->slideVelX;
src/game/mario.c:    m->vel[2] = (f32) m->slideVelZ;
src/game/mario.c:    if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE) {
src/game/mario.c:    if (m->floor) {
src/game/mario.c:        switch (m->floor->type) {
src/game/mario.c:    if (m->action == ACT_CRAWLING && m->floor->normal.y > 0.5f && floorClass == SURFACE_CLASS_DEFAULT) {
src/game/mario.c:    s16 terrainType = m->area->terrainType & TERRAIN_MASK;
src/game/mario.c:    if (m->floor) {
src/game/mario.c:        floorType = m->floor->type;
src/game/mario.c:        if ((gCurrLevelNum != LEVEL_LLL) && (m->floorHeight < (m->waterLevel - 10))) {
src/game/mario.c:    s16 faceAngleYaw = m->faceAngle[1];
src/game/mario.c:    if (turnYaw && m->forwardVel < 0.0f) {
src/game/mario.c:    faceAngleYaw = m->floorAngle - faceAngleYaw;
src/game/mario.c:    // if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE
src/game/mario.c:    //     && m->floor->normal.y < 0.9998477f //~cos(1 deg)
src/game/mario.c:        return m->floor->normal.y <= normY;
src/game/mario.c:        return m->ceil->normal.y >= normY;
src/game/mario.c:    if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SLIDE
src/game/mario.c:        && m->floor->normal.y < 0.9998477f //~cos(1 deg)
src/game/mario.c:        return m->floor->normal.y <= normY;
src/game/mario.c:        return m->ceil->normal.y >= normY;
src/game/mario.c:        result = m->floor->normal.y <= normY;
src/game/mario.c:        return m->floor->normal.y <= normY;
src/game/mario.c:        return m->ceil->normal.y >= normY;
src/game/mario.c:    f32 y = sins(m->faceAngle[1] + angleFromMario) * distFromMario;
src/game/mario.c:    f32 x = coss(m->faceAngle[1] + angleFromMario) * distFromMario;
src/game/mario.c:    floorY = find_surface_down(m->pos[0] + y, m->pos[1] + 100.0f, m->pos[2] + x, &floor);
src/game/mario.c:    f32 x = sins(m->faceAngle[1] + yawOffset) * 5.0f;
src/game/mario.c:    f32 z = coss(m->faceAngle[1] + yawOffset) * 5.0f;
src/game/mario.c:        forwardFloorY = find_surface_down(m->pos[0] + x, m->pos[1] + 100.0f, m->pos[2] + z, &floor);
src/game/mario.c:        backwardFloorY = find_surface_down(m->pos[0] - x, m->pos[1] + 100.0f, m->pos[2] - z, &floor);
src/game/mario.c:        forwardFloorY = find_surface_up(m->pos[0] + x, m->pos[1] + 100.0f, m->pos[2] + z, &floor);
src/game/mario.c:        backwardFloorY = find_surface_up(m->pos[0] - x, m->pos[1] + 100.0f, m->pos[2] - z, &floor);
src/game/mario.c:    forwardYDelta = forwardFloorY - m->pos[1];
src/game/mario.c:    backwardYDelta = m->pos[1] - backwardFloorY;
src/game/mario.c:    u32 action = m->action;
src/game/mario.c:    s32 camPreset = m->area->camera->mode;
src/game/mario.c:        set_camera_mode(m->area->camera, -1, 1);
src/game/mario.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario.c:    m->marioObj->oMarioSteepJumpYaw = m->faceAngle[1];
src/game/mario.c:    if (m->forwardVel > 0.0f) {
src/game/mario.c:        // undefined behavior if m->floorAngle >= 0.
src/game/mario.c:        s16 angleTemp = m->floorAngle + 0x8000;
src/game/mario.c:        s16 faceAngleTemp = m->faceAngle[1] - angleTemp;
src/game/mario.c:        f32 y = sins(faceAngleTemp) * m->forwardVel;
src/game/mario.c:        f32 x = coss(faceAngleTemp) * m->forwardVel * 0.75f;
src/game/mario.c:        m->forwardVel = sqrtf(y * y + x * x);
src/game/mario.c:        m->faceAngle[1] = atan2s(x, y) + angleTemp;
src/game/mario.c:        m->vel[1] = initialVelY + m->forwardVel * multiplier;
src/game/mario.c:        m->vel[1] = (initialVelY - m->forwardVel) * multiplier;
src/game/mario.c:    if (m->squishTimer != 0 || m->quicksandDepth > 1.0f) {
src/game/mario.c:        m->vel[1] *= 0.5f;
src/game/mario.c:    if (m->squishTimer != 0 || m->quicksandDepth >= 1.0f) {
src/game/mario.c:            m->forwardVel *= 0.8f;
src/game/mario.c:            m->marioObj->header.gfx.unk38.animID = -1;
src/game/mario.c:            m->forwardVel = -16.0f;
src/game/mario.c:            m->forwardVel *= 0.8f;
src/game/mario.c:            m->vel[1] = 31.5f;
src/game/mario.c:            m->forwardVel = 8.0f;
src/game/mario.c:            m->marioObj->header.gfx.unk38.animID = -1;
src/game/mario.c:            m->forwardVel *= 0.8f;
src/game/mario.c:            if (m->forwardVel < 24.0f) {
src/game/mario.c:                m->forwardVel = 24.0f;
src/game/mario.c:            m->wallKickTimer = 0;
src/game/mario.c:            m->forwardVel = 8.0f;
src/game/mario.c:            m->faceAngle[1] = m->intendedYaw;
src/game/mario.c:            m->marioObj->header.gfx.unk38.animID = -1;
src/game/mario.c:            m->faceAngle[0] = -0x2000;
src/game/mario.c:            m->vel[1] = 84.0f;
src/game/mario.c:                m->forwardVel = 0.0f;
src/game/mario.c:            if ((fowardVel = m->forwardVel + 15.0f) > 48.0f) {
src/game/mario.c:            m->marioObj->header.gfx.unk38.animID = -1;
src/game/mario.c:            m->marioObj->oMarioLongJumpIsSlow = m->forwardVel > 16.0f ? FALSE : TRUE;
src/game/mario.c:            if ((m->forwardVel *= 1.5f) > 48.0f) {
src/game/mario.c:                m->forwardVel = 48.0f;
src/game/mario.c:            m->vel[1] = 12.0f;
src/game/mario.c:            if (m->forwardVel < 32.0f) {
src/game/mario.c:                m->forwardVel = 32.0f;
src/game/mario.c:            m->vel[1] = 20.0f;
src/game/mario.c:    m->peakHeight = m->pos[1];
src/game/mario.c:    m->flags |= MARIO_UNKNOWN_08;
src/game/mario.c:    f32 forwardVel = m->forwardVel;
src/game/mario.c:    f32 mag = min(m->intendedMag, 8.0f);
src/game/mario.c:                    m->forwardVel = mag;
src/game/mario.c:            m->marioObj->oMarioWalkingPitch = 0;
src/game/mario.c:                m->forwardVel = mag / 2.0f;
src/game/mario.c:        m->vel[1] = 32.0f;
src/game/mario.c:            m->vel[1] = 52.0f;
src/game/mario.c:            m->vel[1] = 64.0f;
src/game/mario.c:    m->flags &= ~(MARIO_ACTION_SOUND_PLAYED | MARIO_MARIO_SOUND_PLAYED);
src/game/mario.c:    if (!(m->action & ACT_FLAG_AIR)) {
src/game/mario.c:        m->flags &= ~MARIO_UNKNOWN_18;
src/game/mario.c:    m->prevAction = m->action;
src/game/mario.c:    m->action = action;
src/game/mario.c:    m->actionArg = actionArg;
src/game/mario.c:    m->actionState = 0;
src/game/mario.c:    m->actionTimer = 0;
src/game/mario.c:    if (m->quicksandDepth >= 11.0f) {
src/game/mario.c:        if (m->heldObj == NULL) {
src/game/mario.c:        if ((m->doubleJumpTimer == 0) || (m->squishTimer != 0)) {
src/game/mario.c:            switch (m->prevAction) {
src/game/mario.c:                    if (m->flags & MARIO_WING_CAP) {
src/game/mario.c:                    } else if (m->forwardVel > 20.0f) {
src/game/mario.c:    m->doubleJumpTimer = 0;
src/game/mario.c:    UNUSED u32 currAction = m->action;
src/game/mario.c:    if (m->quicksandDepth >= 11.0f) {
src/game/mario.c:        if (m->heldObj == NULL) {
src/game/mario.c:    m->hurtCounter = hurtCounter;
src/game/mario.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario.c:    set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario.c:    vec3s_set(m->angleVel, 0, 0, 0);
src/game/mario.c:    if (m->heldObj == NULL) {
src/game/mario.c:    m->forwardVel = m->forwardVel / 4.0f;
src/game/mario.c:    m->vel[1] = m->vel[1] / 2.0f;
src/game/mario.c:    m->pos[1] = m->waterLevel - 100;
src/game/mario.c:    m->faceAngle[2] = 0;
src/game/mario.c:    vec3s_set(m->angleVel, 0, 0, 0);
src/game/mario.c:    if ((m->action & ACT_FLAG_DIVING) == 0) {
src/game/mario.c:        m->faceAngle[0] = 0;
src/game/mario.c:    if (m->area->camera->mode != CAMERA_MODE_WATER_SURFACE) {
src/game/mario.c:        set_camera_mode(m->area->camera, CAMERA_MODE_WATER_SURFACE, 1);
src/game/mario.c:    if (m->squishTimer != 0xFF) {
src/game/mario.c:        if (m->squishTimer == 0) {
src/game/mario.c:            vec3f_set(m->marioObj->header.gfx.scale, 1.0f, 1.0f, 1.0f);
src/game/mario.c:        else if (m->squishTimer <= 16) {
src/game/mario.c:            m->squishTimer -= 1;
src/game/mario.c:            m->marioObj->header.gfx.scale[1] =
src/game/mario.c:                1.0f - ((sSquishScaleOverTime[15 - m->squishTimer] * 0.6f) / 100.0f);
src/game/mario.c:            m->marioObj->header.gfx.scale[0] =
src/game/mario.c:                ((sSquishScaleOverTime[15 - m->squishTimer] * 0.4f) / 100.0f) + 1.0f;
src/game/mario.c:            m->marioObj->header.gfx.scale[2] = m->marioObj->header.gfx.scale[0];
src/game/mario.c:            m->squishTimer -= 1;
src/game/mario.c:            vec3f_set(m->marioObj->header.gfx.scale, 1.4f, 0.4f, 1.4f);
src/game/mario.c:            ((m->floor->normal.x * m->floor->normal.x) + (m->floor->normal.z * m->floor->normal.z)));
src/game/mario.c:        floor_nY = m->floor->normal.y;
src/game/mario.c:        print_text_fmt_int(210, 72, "SPD %d", m->forwardVel);
src/game/mario.c:        print_text_fmt_int(210, 56, "STA %x", (m->action & ACT_ID_MASK));
src/game/mario.c:    if (m->controller->buttonPressed & A_BUTTON) {
src/game/mario.c:        m->input |= INPUT_A_PRESSED;
src/game/mario.c:    if (m->controller->buttonDown & A_BUTTON) {
src/game/mario.c:        m->input |= INPUT_A_DOWN;
src/game/mario.c:    if (m->squishTimer == 0) {
src/game/mario.c:        if (m->controller->buttonPressed & B_BUTTON) {
src/game/mario.c:            m->input |= INPUT_B_PRESSED;
src/game/mario.c:        if (m->controller->buttonDown & Z_TRIG) {
src/game/mario.c:            m->input |= INPUT_Z_DOWN;
src/game/mario.c:        if (m->controller->buttonPressed & Z_TRIG) {
src/game/mario.c:            m->input |= INPUT_Z_PRESSED;
src/game/mario.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario.c:        m->framesSinceA = 0;
src/game/mario.c:    } else if (m->framesSinceA < 0xFF) {
src/game/mario.c:        m->framesSinceA += 1;
src/game/mario.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario.c:        m->framesSinceB = 0;
src/game/mario.c:    } else if (m->framesSinceB < 0xff) {
src/game/mario.c:        m->framesSinceB += 1;
src/game/mario.c:    struct Controller *controller = m->controller;
src/game/mario.c:    if (m->squishTimer == 0) {
src/game/mario.c:        m->intendedMag = mag / 2.0f;
src/game/mario.c:        m->intendedMag = mag / 8.0f;
src/game/mario.c:    if (m->intendedMag > 0.0f) {
src/game/mario.c:            m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
src/game/mario.c:            m->intendedYaw = atan2s(-controller->stickY, controller->stickX)-newcam_yaw+0x4000;
src/game/mario.c:        m->input |= INPUT_NONZERO_ANALOG;
src/game/mario.c:        m->intendedYaw = m->faceAngle[1];
src/game/mario.c:    f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 60.0f, 50.0f);
src/game/mario.c:    f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f, 24.0f);
src/game/mario.c:        m->floorHeight = find_surface_down(m->pos[0], m->pos[1], m->pos[2], &m->floor);
src/game/mario.c:        m->floorHeight = find_surface_up(m->pos[0], m->pos[1], m->pos[2], &m->ceil);
src/game/mario.c:    // if (m->floor == NULL) {
src/game/mario.c:    //     vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
src/game/mario.c:    //     m->floorHeight = find_surface_down(m->pos[0], m->pos[1], m->pos[2], &m->floor);
src/game/mario.c:        m->ceilHeight = vec3f_find_ceil(&m->pos[0], m->floorHeight, &m->ceil);
src/game/mario.c:        m->ceilHeight = find_surface_down(m->pos[0], m->pos[1], m->pos[2], &m->floor);
src/game/mario.c:    gasLevel = find_poison_gas_level(m->pos[0], m->pos[2]);
src/game/mario.c:    m->waterLevel = find_water_level(m->pos[0], m->pos[2]);
src/game/mario.c:    if (m->floor) {
src/game/mario.c:        m->floorAngle = atan2s(m->floor->normal.z, m->floor->normal.x);
src/game/mario.c:        m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
src/game/mario.c:        if ((m->pos[1] > m->waterLevel - 40) && mario_floor_is_slippery(m)) {
src/game/mario.c:            m->input |= INPUT_ABOVE_SLIDE;
src/game/mario.c:        if ((m->floor->flags & SURFACE_FLAG_DYNAMIC)
src/game/mario.c:            || (m->ceil && m->ceil->flags & SURFACE_FLAG_DYNAMIC)) {
src/game/mario.c:            ceilToFloorDist = m->ceilHeight - m->floorHeight;
src/game/mario.c:            //     m->input |= INPUT_SQUISHED;
src/game/mario.c:        if (m->pos[1] > m->floorHeight + 100.0f) {
src/game/mario.c:            m->input |= INPUT_OFF_FLOOR;
src/game/mario.c:        if (m->pos[1] < (m->waterLevel - 10)) {
src/game/mario.c:            m->input |= INPUT_IN_WATER;
src/game/mario.c:        if (m->pos[1] < (gasLevel - 100.0f)) {
src/game/mario.c:            m->input |= INPUT_IN_POISON_GAS;
src/game/mario.c:    m->particleFlags = 0;
src/game/mario.c:    m->input = 0;
src/game/mario.c:    m->collidedObjInteractTypes = m->marioObj->collidedObjInteractTypes;
src/game/mario.c:    m->flags &= 0xFFFFFF;
src/game/mario.c:        if (m->action & ACT_FLAG_ALLOW_FIRST_PERSON) {
src/game/mario.c:            m->input |= INPUT_FIRST_PERSON;
src/game/mario.c:    if (!(m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED))) {
src/game/mario.c:        m->input |= INPUT_UNKNOWN_5;
src/game/mario.c:    if (m->marioObj->oInteractStatus
src/game/mario.c:        m->input |= INPUT_UNKNOWN_10;
src/game/mario.c:    if (m->wallKickTimer > 0) {
src/game/mario.c:        m->wallKickTimer--;
src/game/mario.c:    if (m->doubleJumpTimer > 0) {
src/game/mario.c:        m->doubleJumpTimer--;
src/game/mario.c:    if ((m->action & ACT_GROUP_MASK) == ACT_GROUP_SUBMERGED) {
src/game/mario.c:        heightBelowWater = (f32)(m->waterLevel - 80) - m->pos[1];
src/game/mario.c:        camPreset = m->area->camera->mode;
src/game/mario.c:        if ((m->action & ACT_FLAG_METAL_WATER)) {
src/game/mario.c:                set_camera_mode(m->area->camera, CAMERA_MODE_CLOSE, 1);
src/game/mario.c:                set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
src/game/mario.c:                set_camera_mode(m->area->camera, CAMERA_MODE_WATER_SURFACE, 1);
src/game/mario.c:            if ((m->action & ACT_FLAG_INTANGIBLE) == 0) {
src/game/mario.c:                if ((m->pos[1] < (f32)(m->waterLevel - 160)) || (m->faceAngle[0] < -0x800)) {
src/game/mario.c:                    m->particleFlags |= PARTICLE_BUBBLE;
src/game/mario.c:    if (m->health >= 0x100) {
src/game/mario.c:        if (((u32) m->healCounter | (u32) m->hurtCounter) == 0) {
src/game/mario.c:            if ((m->input & INPUT_IN_POISON_GAS) && ((m->action & ACT_FLAG_INTANGIBLE) == 0)) {
src/game/mario.c:                if (((m->flags & MARIO_METAL_CAP) == 0) && (gDebugLevelSelect == 0)) {
src/game/mario.c:                    m->health -= 4;
src/game/mario.c:                if ((m->action & ACT_FLAG_SWIMMING) && ((m->action & ACT_FLAG_INTANGIBLE) == 0)) {
src/game/mario.c:                    terrainIsSnow = (m->area->terrainType & TERRAIN_MASK) == TERRAIN_SNOW;
src/game/mario.c:                    if ((m->pos[1] >= (m->waterLevel - 140)) && !terrainIsSnow) {
src/game/mario.c:                        m->health += 0x1A;
src/game/mario.c:                        m->health -= (terrainIsSnow ? 3 : 1);
src/game/mario.c:        if (m->healCounter > 0) {
src/game/mario.c:            m->health += 0x40;
src/game/mario.c:            m->healCounter--;
src/game/mario.c:        if (m->hurtCounter > 0) {
src/game/mario.c:            m->health -= 0x40;
src/game/mario.c:            m->hurtCounter--;
src/game/mario.c:        if (m->health >= 0x881) {
src/game/mario.c:            m->health = 0x880;
src/game/mario.c:        if (m->health < 0x100) {
src/game/mario.c:            m->health = 0xFF;
src/game/mario.c:        if (((m->action & ACT_GROUP_MASK) == ACT_GROUP_SUBMERGED) && (m->health < 0x300)) {
src/game/mario.c:    m->marioBodyState->action = m->action;
src/game/mario.c:    m->statusForCamera->action = m->action;
src/game/mario.c:    vec3s_copy(m->statusForCamera->faceAngle, m->faceAngle);
src/game/mario.c:    if ((m->flags & MARIO_UNKNOWN_25) == 0) {
src/game/mario.c:        vec3f_copy(m->statusForCamera->pos, m->pos);
src/game/mario.c:    struct MarioBodyState *bodyState = m->marioBodyState;
src/game/mario.c:    m->flags &= ~MARIO_METAL_SHOCK;
src/game/mario.c:    struct Object *o = m->marioObj;
src/game/mario.c:        *(f32 *) ((u8 *) o->header.gfx.throwMatrix + 0x34) -= m->quicksandDepth;
src/game/mario.c:    o->header.gfx.pos[1] -= m->quicksandDepth;
src/game/mario.c:    u32 flags = m->flags;
src/game/mario.c:    if (m->capTimer > 0) {
src/game/mario.c:        action = m->action;
src/game/mario.c:        if ((m->capTimer <= 60)
src/game/mario.c:            m->capTimer -= 1;
src/game/mario.c:        if (m->capTimer == 0) {
src/game/mario.c:            m->flags &= ~(MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP);
src/game/mario.c:            if ((m->flags & (MARIO_NORMAL_CAP | MARIO_VANISH_CAP | MARIO_METAL_CAP | MARIO_WING_CAP))
src/game/mario.c:                m->flags &= ~MARIO_CAP_ON_HEAD;
src/game/mario.c:        if (m->capTimer == 0x3C) {
src/game/mario.c:        if ((m->capTimer < 0x40) && ((1ULL << m->capTimer) & sCapFlickerFrames)) {
src/game/mario.c:    struct MarioBodyState *bodyState = m->marioBodyState;
src/game/mario.c:    if (m->invincTimer >= 3) {
src/game/mario.c:    if (m->action & ACT_FLAG_SHORT_HITBOX) {
src/game/mario.c:        m->marioObj->hitboxHeight = 100.0f;
src/game/mario.c:        m->marioObj->hitboxHeight = 160.0f;
src/game/mario.c:    if ((m->flags & MARIO_TELEPORTING) && (m->fadeWarpOpacity != 0xFF)) {
src/game/mario.c:        bodyState->modelState |= (0x100 | m->fadeWarpOpacity);
src/game/mario_actions_stationary.c:    if (m->floor->normal.y < 0.29237169f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:        m->faceAngle[1] = (s16) m->intendedYaw;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_Z_DOWN) {
src/game/mario_actions_stationary.c:    if (m->floor->normal.y < 0.29237169f) {
src/game/mario_actions_stationary.c:    if (m->heldObj->oInteractionSubtype & INT_SUBTYPE_DROP_IMMEDIATELY) {
src/game/mario_actions_stationary.c:        m->heldObj->oInteractionSubtype =
src/game/mario_actions_stationary.c:            (s32)(m->heldObj->oInteractionSubtype & ~INT_SUBTYPE_DROP_IMMEDIATELY);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:        m->faceAngle[1] = (s16) m->intendedYaw;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_Z_DOWN) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_IN_POISON_GAS) {
src/game/mario_actions_stationary.c:    if (!(m->actionArg & 1) && m->health < 0x300) {
src/game/mario_actions_stationary.c:    if (m->actionState == 3) {
src/game/mario_actions_stationary.c:        if ((m->area->terrainType & TERRAIN_MASK) == TERRAIN_SNOW) {
src/game/mario_actions_stationary.c:    if (m->actionArg & 1) {
src/game/mario_actions_stationary.c:        switch (m->actionState) {
src/game/mario_actions_stationary.c:            if (++m->actionState == 3) {
src/game/mario_actions_stationary.c:                f32 sp24 = m->pos[1] - find_floor_height_relative_polar(m, -0x8000, 60.0f);
src/game/mario_actions_stationary.c:                if (sp24 < -24.0f || 24.0f < sp24 || m->floor->flags & 1) {
src/game/mario_actions_stationary.c:                    m->actionState = 0;
src/game/mario_actions_stationary.c:                    m->actionTimer++;
src/game/mario_actions_stationary.c:                    if (m->actionTimer < 10) {
src/game/mario_actions_stationary.c:                        m->actionState = 0;
src/game/mario_actions_stationary.c:    if (m->actionState == actionState && m->marioObj->header.gfx.unk38.animFrame == animFrame) {
src/game/mario_actions_stationary.c:        play_sound(sound, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:    if (m->actionState == 4) {
src/game/mario_actions_stationary.c:    switch (m->actionState) {
src/game/mario_actions_stationary.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:    play_anim_sound(m, 3, 15, m->terrainSoundAddend + SOUND_ACTION_TERRAIN_BODY_HIT_GROUND);
src/game/mario_actions_stationary.c:        m->actionState++;
src/game/mario_actions_stationary.c:    if (m->actionState == 2) {
src/game/mario_actions_stationary.c:            play_sound(SOUND_MARIO_YAWNING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->actionState == 1) {
src/game/mario_actions_stationary.c:            play_sound(SOUND_MARIO_IMA_TIRED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->actionState == 2) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_A41F /* ? */) {
src/game/mario_actions_stationary.c:        return set_mario_action(m, ACT_WAKING_UP, m->actionState);
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:        return set_mario_action(m, ACT_WAKING_UP, m->actionState);
src/game/mario_actions_stationary.c:    if (m->pos[1] - find_floor_height_relative_polar(m, -0x8000, 60.0f) > 24.0f) {
src/game/mario_actions_stationary.c:        return set_mario_action(m, ACT_WAKING_UP, m->actionState);
src/game/mario_actions_stationary.c:    m->marioBodyState->eyeState = MARIO_EYES_CLOSED;
src/game/mario_actions_stationary.c:    switch (m->actionState) {
src/game/mario_actions_stationary.c:            if (sp24 == -1 && !m->actionTimer) {
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                m->actionTimer++;
src/game/mario_actions_stationary.c:                if (m->actionTimer > 45) {
src/game/mario_actions_stationary.c:                    m->actionState++;
src/game/mario_actions_stationary.c:                m->actionState++;
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_SNORING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (!m->actionTimer) {
src/game/mario_actions_stationary.c:        func_803205E8(SOUND_MARIO_SNORING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        func_803205E8(SOUND_MARIO_SNORING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        func_803205E8(SOUND_MARIO_SNORING3, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    m->actionTimer++;
src/game/mario_actions_stationary.c:    if (m->actionTimer > 20) {
src/game/mario_actions_stationary.c:    set_mario_animation(m, !m->actionArg ? MARIO_ANIM_WAKE_FROM_SLEEP : MARIO_ANIM_WAKE_FROM_LYING);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_A41F) {
src/game/mario_actions_stationary.c:        m->actionState = 2;
src/game/mario_actions_stationary.c:    switch (m->actionState) {
src/game/mario_actions_stationary.c:                m->particleFlags |= PARTICLE_BREATH;
src/game/mario_actions_stationary.c:                play_sound(SOUND_MARIO_PANTING_COLD, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                play_sound(SOUND_ACTION_CLAP_HANDS_COLD, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:                m->actionState = 1;
src/game/mario_actions_stationary.c:                play_sound(SOUND_ACTION_CLAP_HANDS_COLD, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_COUGHING3, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_COUGHING2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:        play_sound(SOUND_MARIO_COUGHING1, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    if (segmented_to_virtual(&bhvJumpingBox) == m->heldObj->behavior) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 30.0f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth < 30.0f) {
src/game/mario_actions_stationary.c:    if (m->quicksandDepth > 70.0f) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (!(m->input & INPUT_Z_DOWN)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->health >= 0x500) {
src/game/mario_actions_stationary.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_stationary.c:    m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->health >= 0x500) {
src/game/mario_actions_stationary.c:    m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (!(m->input & INPUT_FIRST_PERSON)
src/game/mario_actions_stationary.c:        && m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->marioObj->header.gfx.unk38.animFrame == 6) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & 0x10) {
src/game/mario_actions_stationary.c:    if (m->actionTimer == 0) {
src/game/mario_actions_stationary.c:        if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK1) {
src/game/mario_actions_stationary.c:    if (++m->actionTimer == 0x30) {
src/game/mario_actions_stationary.c:    sp1E = (m->actionTimer % 0x10) << 0xC;
src/game/mario_actions_stationary.c:    sp18 = (f32)(((f32)(6 - m->actionTimer / 8) * 8.0f) + 4.0f);
src/game/mario_actions_stationary.c:    vec3f_set(m->vel, 0.0f, 0.0f, 0.0f);
src/game/mario_actions_stationary.c:        m->pos[1] = sins(sp1E) * sp18 + m->floorHeight;
src/game/mario_actions_stationary.c:        m->pos[1] = m->floorHeight - sins(sp1E) * sp18;
src/game/mario_actions_stationary.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_stationary.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_stationary.c:    if (!(m->input & INPUT_Z_DOWN) || m->marioObj->header.gfx.unk38.animFrame >= 6) {
src/game/mario_actions_stationary.c:        m->input &= -3;
src/game/mario_actions_stationary.c:    m->input &= -0x2011;
src/game/mario_actions_stationary.c:    m->input &= -0x2001;
src/game/mario_actions_stationary.c:                  !m->marioObj->oMarioLongJumpIsSlow ? MARIO_ANIM_CROUCH_FROM_FAST_LONGJUMP
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (++m->actionTimer == 4) {
src/game/mario_actions_stationary.c:    m->actionState = 1;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->angleVel[1] > 0) {
src/game/mario_actions_stationary.c:        m->angleVel[1] -= 0x400;
src/game/mario_actions_stationary.c:        if (m->angleVel[1] < 0) {
src/game/mario_actions_stationary.c:            m->angleVel[1] = 0;
src/game/mario_actions_stationary.c:        m->twirlYaw += m->angleVel[1];
src/game/mario_actions_stationary.c:    m->marioObj->header.gfx.angle[1] += m->twirlYaw;
src/game/mario_actions_stationary.c:        if (m->angleVel[1] == 0) {
src/game/mario_actions_stationary.c:            m->faceAngle[1] += m->twirlYaw;
src/game/mario_actions_stationary.c:    m->actionState = 1;
src/game/mario_actions_stationary.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_stationary.c:    sp1C = 0 != (m->input & (INPUT_UNKNOWN_10 | 0xC));
src/game/mario_actions_stationary.c:    if (m->actionState == 0) {
src/game/mario_actions_stationary.c:        set_camera_mode(m->area->camera, CAMERA_MODE_C_UP, 0x10);
src/game/mario_actions_stationary.c:        m->actionState = 1;
src/game/mario_actions_stationary.c:        if (!(m->input & INPUT_FIRST_PERSON) || sp1C) {
src/game/mario_actions_stationary.c:            set_camera_mode(m->area->camera, -1, 1);
src/game/mario_actions_stationary.c:    if (m->floor->type == SURFACE_LOOK_UP_WARP) {
src/game/mario_actions_stationary.c:            sp1A = m->statusForCamera->headRotation[0];
src/game/mario_actions_stationary.c:            sp18 = ((m->statusForCamera->headRotation[1] * 4) / 3) + m->faceAngle[1];
src/game/mario_actions_stationary.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_stationary.c:        if (m->action == ACT_SPAWN_SPIN_LANDING) {
src/game/mario_actions_stationary.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_stationary.c:    if (m->action != 0x0002020E) {
src/game/mario_actions_stationary.c:        if (m->health < 0x100) {
src/game/mario_actions_stationary.c:    switch (m->action) {
src/game/mario_actions_stationary.c:        if (m->input & INPUT_IN_WATER) {
src/game/mario_actions_stationary.c:            m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_submerged.c:    s16 atSurface = m->pos[1] >= m->waterLevel - 130;
src/game/mario_actions_submerged.c:        m->particleFlags |= particleFlag;
src/game/mario_actions_submerged.c:            play_sound(SOUND_ACTION_UNKNOWN431, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    return (m->waterLevel - 80) - m->pos[1] < 400.0f;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:        if (m->action & ACT_FLAG_INVULNERABLE) {
src/game/mario_actions_submerged.c:    } else if (!(m->action & ACT_FLAG_MOVING)) {
src/game/mario_actions_submerged.c:            vec3f_copy(m->pos, nextPos);
src/game/mario_actions_submerged.c:            m->floor = floor;
src/game/mario_actions_submerged.c:            m->floorHeight = floorHeight;
src/game/mario_actions_submerged.c:        vec3f_set(m->pos, nextPos[0], ceilHeight - 160.0f, nextPos[2]);
src/game/mario_actions_submerged.c:        m->floor = floor;
src/game/mario_actions_submerged.c:        m->floorHeight = floorHeight;
src/game/mario_actions_submerged.c:        vec3f_set(m->pos, nextPos[0], floorHeight, nextPos[2]);
src/game/mario_actions_submerged.c:        m->floor = floor;
src/game/mario_actions_submerged.c:        m->floorHeight = floorHeight;
src/game/mario_actions_submerged.c:    if (m->floor->type == SURFACE_FLOWING_WATER) {
src/game/mario_actions_submerged.c:        s16 currentAngle = m->floor->force << 8;
src/game/mario_actions_submerged.c:        f32 currentSpeed = sWaterCurrentSpeeds[m->floor->force >> 8];
src/game/mario_actions_submerged.c:            f32 dx = whirlpool->pos[0] - m->pos[0];
src/game/mario_actions_submerged.c:            f32 dy = whirlpool->pos[1] - m->pos[1];
src/game/mario_actions_submerged.c:            f32 dz = whirlpool->pos[2] - m->pos[2];
src/game/mario_actions_submerged.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:    vec3f_copy(step, m->vel);
src/game/mario_actions_submerged.c:    if (m->action & ACT_FLAG_SWIMMING) {
src/game/mario_actions_submerged.c:    nextPos[0] = m->pos[0] + step[0];
src/game/mario_actions_submerged.c:    nextPos[1] = m->pos[1] + step[1];
src/game/mario_actions_submerged.c:    nextPos[2] = m->pos[2] + step[2];
src/game/mario_actions_submerged.c:    if (nextPos[1] > m->waterLevel - 80) {
src/game/mario_actions_submerged.c:        nextPos[1] = m->waterLevel - 80;
src/game/mario_actions_submerged.c:        m->vel[1] = 0.0f;
src/game/mario_actions_submerged.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_submerged.c:    vec3s_set(marioObj->header.gfx.angle, -m->faceAngle[0], m->faceAngle[1], m->faceAngle[2]);
src/game/mario_actions_submerged.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:    m->angleVel[0] = 0;
src/game/mario_actions_submerged.c:    m->angleVel[1] = 0;
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 0.0f, 1.0f, 1.0f);
src/game/mario_actions_submerged.c:    m->vel[1] = approach_f32(m->vel[1], buoyancy, 2.0f, 1.0f);
src/game/mario_actions_submerged.c:    m->faceAngle[0] = approach_s32(m->faceAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    m->faceAngle[2] = approach_s32(m->faceAngle[2], 0, 0x100, 0x100);
src/game/mario_actions_submerged.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    if (m->action & ACT_FLAG_STATIONARY) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 2.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel > maxSpeed) {
src/game/mario_actions_submerged.c:        m->forwardVel = maxSpeed;
src/game/mario_actions_submerged.c:    if (m->forwardVel > decelThreshold) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 0.5f;
src/game/mario_actions_submerged.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[1] = m->forwardVel * sins(m->faceAngle[0]) + buoyancy;
src/game/mario_actions_submerged.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    s16 targetYawVel = -(s16)(10.0f * m->controller->stickX);
src/game/mario_actions_submerged.c:        if (m->angleVel[1] < 0) {
src/game/mario_actions_submerged.c:            m->angleVel[1] += 0x40;
src/game/mario_actions_submerged.c:            if (m->angleVel[1] > 0x10) {
src/game/mario_actions_submerged.c:                m->angleVel[1] = 0x10;
src/game/mario_actions_submerged.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x10, 0x20);
src/game/mario_actions_submerged.c:        if (m->angleVel[1] > 0) {
src/game/mario_actions_submerged.c:            m->angleVel[1] -= 0x40;
src/game/mario_actions_submerged.c:            if (m->angleVel[1] < -0x10) {
src/game/mario_actions_submerged.c:                m->angleVel[1] = -0x10;
src/game/mario_actions_submerged.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x20, 0x10);
src/game/mario_actions_submerged.c:        m->angleVel[1] = approach_s32(m->angleVel[1], 0, 0x40, 0x40);
src/game/mario_actions_submerged.c:    m->faceAngle[1] += m->angleVel[1];
src/game/mario_actions_submerged.c:    m->faceAngle[2] = -m->angleVel[1] * 8;
src/game/mario_actions_submerged.c:    s16 targetPitch = -(s16)(252.0f * m->controller->stickY);
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] < 0) {
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] < targetPitch) {
src/game/mario_actions_submerged.c:        if ((m->faceAngle[0] += pitchVel) > targetPitch) {
src/game/mario_actions_submerged.c:            m->faceAngle[0] = targetPitch;
src/game/mario_actions_submerged.c:    } else if (m->faceAngle[0] > targetPitch) {
src/game/mario_actions_submerged.c:        if ((m->faceAngle[0] -= pitchVel) < targetPitch) {
src/game/mario_actions_submerged.c:            m->faceAngle[0] = targetPitch;
src/game/mario_actions_submerged.c:    s16 *val = &m->marioBodyState->headAngle[0];
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] > 0) {
src/game/mario_actions_submerged.c:        *val = approach_s32(*val, m->faceAngle[0] / 2, 0x80, 0x200);
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->faceAngle[0] < -0x1000) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:        m, m->actionArg == 0 ? MARIO_ANIM_WATER_ACTION_END_WITH_OBJ : MARIO_ANIM_STOP_GRAB_OBJ_WATER,
src/game/mario_actions_submerged.c:    D_80339FD4 = m->faceAngle[0] / 256.0f + 20.0f;
src/game/mario_actions_submerged.c:    if (D_80339FD2 != 0 && m->pos[1] > m->waterLevel - 85 && m->faceAngle[0] >= 0) {
src/game/mario_actions_submerged.c:            m->marioObj->header.gfx.pos[1] += D_80339FD4 * sins(D_80339FD0);
src/game/mario_actions_submerged.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:            if (m->faceAngle[0] < floorPitch) {
src/game/mario_actions_submerged.c:                m->faceAngle[0] = floorPitch;
src/game/mario_actions_submerged.c:            if (m->faceAngle[0] > -0x3000) {
src/game/mario_actions_submerged.c:                m->faceAngle[0] -= 0x100;
src/game/mario_actions_submerged.c:            if (m->controller->stickY == 0.0f) {
src/game/mario_actions_submerged.c:                if (m->faceAngle[0] > 0.0f) {
src/game/mario_actions_submerged.c:                    m->faceAngle[0] += 0x200;
src/game/mario_actions_submerged.c:                    if (m->faceAngle[0] > 0x3F00) {
src/game/mario_actions_submerged.c:                        m->faceAngle[0] = 0x3F00;
src/game/mario_actions_submerged.c:                    m->faceAngle[0] -= 0x200;
src/game/mario_actions_submerged.c:                    if (m->faceAngle[0] < -0x3F00) {
src/game/mario_actions_submerged.c:                        m->faceAngle[0] = -0x3F00;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = approach_s32(m->marioBodyState->headAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    s16 animFrame = m->marioObj->header.gfx.unk38.animFrame;
src/game/mario_actions_submerged.c:    if (animFrame == 0 || animFrame == 12) play_sound(SOUND_ACTION_UNKNOWN434, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    s32 probe = (s32)(m->pos[1] + 1.5f);
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:        if (probe >= m->waterLevel - 80 && m->faceAngle[0] >= 0 && m->controller->stickY < -60.0f) {
src/game/mario_actions_submerged.c:            vec3s_set(m->angleVel, 0, 0, 0);
src/game/mario_actions_submerged.c:            m->vel[1] = 62.0f;
src/game/mario_actions_submerged.c:            if (m->heldObj == NULL) {
src/game/mario_actions_submerged.c:    if (m->actionArg == 0) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (++m->actionTimer == 14) {
src/game/mario_actions_submerged.c:    if (m->actionTimer < 6) {
src/game/mario_actions_submerged.c:        m->forwardVel += 0.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 9) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 2) {
src/game/mario_actions_submerged.c:        if (m->actionTimer < 6 && (m->input & INPUT_A_PRESSED)) {
src/game/mario_actions_submerged.c:            m->actionState = 1;
src/game/mario_actions_submerged.c:        if (m->actionTimer == 9 && m->actionState == 1) {
src/game/mario_actions_submerged.c:            m->actionState = 0;
src/game/mario_actions_submerged.c:            m->actionTimer = 1;
src/game/mario_actions_submerged.c:    if (m->actionTimer == 1) {
src/game/mario_actions_submerged.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    if (m->actionTimer < 6) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 15) {
src/game/mario_actions_submerged.c:    if ((m->input & INPUT_A_DOWN) && m->actionTimer >= 7) {
src/game/mario_actions_submerged.c:        if (m->actionTimer == 7 && sSwimStrength < 280) {
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 7) {
src/game/mario_actions_submerged.c:    m->actionTimer++;
src/game/mario_actions_submerged.c:    m->forwardVel -= 0.25f;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_submerged.c:        if (m->actionTimer == 0 && sSwimStrength < 280) {
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 12.0f, 0.1f, 0.15f);
src/game/mario_actions_submerged.c:    m->actionTimer = 1;
src/game/mario_actions_submerged.c:    if (m->forwardVel < 14.0f) {
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (++m->actionTimer == 17) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->actionTimer < 6) {
src/game/mario_actions_submerged.c:        m->forwardVel += 0.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 9) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.5f;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 2) {
src/game/mario_actions_submerged.c:        if (m->actionTimer < 6 && (m->input & INPUT_A_PRESSED)) {
src/game/mario_actions_submerged.c:            m->actionState = 1;
src/game/mario_actions_submerged.c:        if (m->actionTimer == 9 && m->actionState == 1) {
src/game/mario_actions_submerged.c:            m->actionState = 0;
src/game/mario_actions_submerged.c:            m->actionTimer = 1;
src/game/mario_actions_submerged.c:    if (m->actionTimer == 1) {
src/game/mario_actions_submerged.c:        play_sound(SOUND_ACTION_SWIM, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 15) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if ((m->input & INPUT_A_DOWN) && m->actionTimer >= 7) {
src/game/mario_actions_submerged.c:    m->actionTimer++;
src/game/mario_actions_submerged.c:    m->forwardVel -= 0.25f;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 12.0f, 0.1f, 0.15f);
src/game/mario_actions_submerged.c:    if (m->forwardVel < 14.0f) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->actionTimer++ == 240) {
src/game/mario_actions_submerged.c:        m->heldObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/mario_actions_submerged.c:        m->heldObj = NULL;
src/game/mario_actions_submerged.c:    m->forwardVel = approach_f32(m->forwardVel, 30.0f, 2.0f, 1.0f);
src/game/mario_actions_submerged.c:    if (m->marioObj->collidedObjInteractTypes & INTERACT_GRABBABLE) {
src/game/mario_actions_submerged.c:        f32 dx = object->oPosX - m->pos[0];
src/game/mario_actions_submerged.c:        f32 dz = object->oPosZ - m->pos[2];
src/game/mario_actions_submerged.c:        s16 dAngleToObject = atan2s(dz, dx) - m->faceAngle[1];
src/game/mario_actions_submerged.c:            m->usedObj = object;
src/game/mario_actions_submerged.c:            m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = approach_s32(m->marioBodyState->headAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    if (m->actionTimer++ == 5) {
src/game/mario_actions_submerged.c:    if (m->forwardVel < 7.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.0f;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = approach_s32(m->marioBodyState->headAngle[0], 0, 0x200, 0x200);
src/game/mario_actions_submerged.c:    switch (m->actionState) {
src/game/mario_actions_submerged.c:                m->actionState = check_water_grab(m) + 1;
src/game/mario_actions_submerged.c:                if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = 0;
src/game/mario_actions_submerged.c:            m->invincTimer = 30;
src/game/mario_actions_submerged.c:        set_mario_action(m, m->health >= 0x100 ? endAction : ACT_WATER_DEATH, 0);
src/game/mario_actions_submerged.c:    common_water_knockback_step(m, MARIO_ANIM_BACKWARDS_WATER_KB, ACT_WATER_IDLE, m->actionArg);
src/game/mario_actions_submerged.c:    common_water_knockback_step(m, MARIO_ANIM_WATER_FORWARD_KB, ACT_WATER_IDLE, m->actionArg);
src/game/mario_actions_submerged.c:    play_sound(SOUND_MOVING_SHOCKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        m->actionTimer++;
src/game/mario_actions_submerged.c:        m->flags |= MARIO_METAL_SHOCK;
src/game/mario_actions_submerged.c:    if (m->actionTimer >= 6) {
src/game/mario_actions_submerged.c:        m->invincTimer = 30;
src/game/mario_actions_submerged.c:        set_mario_action(m, m->health < 0x100 ? ACT_WATER_DEATH : ACT_WATER_IDLE, 0);
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[0] = 0;
src/game/mario_actions_submerged.c:    switch (m->actionState) {
src/game/mario_actions_submerged.c:            m->marioBodyState->eyeState = MARIO_EYES_HALF_CLOSED;
src/game/mario_actions_submerged.c:                m->actionState = 1;
src/game/mario_actions_submerged.c:            m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_submerged.c:            if (m->marioObj->header.gfx.unk38.animFrame == 30) {
src/game/mario_actions_submerged.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_submerged.c:    s32 stateFlags = m->heldObj != NULL;
src/game/mario_actions_submerged.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/mario_actions_submerged.c:    } else if ((m->prevAction & ACT_FLAG_DIVING) || (m->input & INPUT_A_DOWN)) {
src/game/mario_actions_submerged.c:    m->actionTimer++;
src/game/mario_actions_submerged.c:    if (m->actionState == 0) {
src/game/mario_actions_submerged.c:        play_sound(SOUND_ACTION_UNKNOWN430, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        if (m->peakHeight - m->pos[1] > 1150.0f) {
src/game/mario_actions_submerged.c:            play_sound(SOUND_MARIO_HAHA_2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_WATER_SPLASH;
src/game/mario_actions_submerged.c:        m->actionState = 1;
src/game/mario_actions_submerged.c:        if (m->prevAction & ACT_FLAG_AIR) {
src/game/mario_actions_submerged.c:    if (stepResult == WATER_STEP_HIT_FLOOR || m->vel[1] >= endVSpeed || m->actionTimer > 20) {
src/game/mario_actions_submerged.c:    m->particleFlags |= PARTICLE_PLUNGE_BUBBLE;
src/game/mario_actions_submerged.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_submerged.c:    struct Object *whirlpool = m->usedObj;
src/game/mario_actions_submerged.c:    f32 dx = m->pos[0] - whirlpool->oPosX;
src/game/mario_actions_submerged.c:    f32 dz = m->pos[2] - whirlpool->oPosZ;
src/game/mario_actions_submerged.c:    if ((marioObj->oMarioWhirlpoolPosY += m->vel[1]) < 0.0f) {
src/game/mario_actions_submerged.c:        if (distance < 16.1f && m->actionTimer++ == 16) {
src/game/mario_actions_submerged.c:    m->vel[1] = -640.0f / (newDistance + 16.0f);
src/game/mario_actions_submerged.c:        dx = newDistance * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:        dz = newDistance * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->pos[0] = whirlpool->oPosX + dx * cosAngleChange + dz * sinAngleChange;
src/game/mario_actions_submerged.c:    m->pos[2] = whirlpool->oPosZ - dx * sinAngleChange + dz * cosAngleChange;
src/game/mario_actions_submerged.c:    m->pos[1] = whirlpool->oPosY + marioObj->oMarioWhirlpoolPosY;
src/game/mario_actions_submerged.c:    m->faceAngle[1] = atan2s(dz, dx) + 0x8000;
src/game/mario_actions_submerged.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_submerged.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_ACTION_SOUND_PLAYED)) {
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_submerged.c:        play_sound(SOUND_ACTION_METAL_STEP_WATER, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_submerged.c:    f32 val = m->intendedMag / 1.5f;
src/game/mario_actions_submerged.c:    if (m->forwardVel <= 0.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.1f;
src/game/mario_actions_submerged.c:    } else if (m->forwardVel <= val) {
src/game/mario_actions_submerged.c:        m->forwardVel += 1.1f - m->forwardVel / 43.0f;
src/game/mario_actions_submerged.c:    } else if (m->floor->normal.y >= 0.95f) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel > 32.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel = 32.0f;
src/game/mario_actions_submerged.c:    m->faceAngle[1] =
src/game/mario_actions_submerged.c:        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_submerged.c:    m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_submerged.c:    m->vel[1] = 0.0f;
src/game/mario_actions_submerged.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_submerged.c:    UNUSED f32 nextY = m->pos[1] + m->vel[1];
src/game/mario_actions_submerged.c:    f32 waterSurface = m->waterLevel - 100;
src/game/mario_actions_submerged.c:    if (m->vel[1] > 0.0f && m->pos[1] > waterSurface) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:        s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_submerged.c:        m->forwardVel += 0.8f * coss(intendedDYaw);
src/game/mario_actions_submerged.c:        m->faceAngle[1] += 0x200 * sins(intendedDYaw);
src/game/mario_actions_submerged.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.25f, 0.25f);
src/game/mario_actions_submerged.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel -= 1.0f;
src/game/mario_actions_submerged.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_submerged.c:        m->forwardVel += 2.0f;
src/game/mario_actions_submerged.c:    m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    switch (m->actionState) {
src/game/mario_actions_submerged.c:    if (is_anim_at_end(m) && ++m->actionState == 3) {
src/game/mario_actions_submerged.c:        m->actionState = 0;
src/game/mario_actions_submerged.c:    if (m->pos[1] >= m->waterLevel - 150) {
src/game/mario_actions_submerged.c:        m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_FIRST_PERSON) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_submerged.c:    if ((val04 = (s32)(m->forwardVel / 4.0f * 0x10000)) < 0x1000) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0;
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_submerged.c:    m->intendedMag *= 0.4f;
src/game/mario_actions_submerged.c:    if ((val04 = (s32)(m->forwardVel / 2.0f * 0x10000)) < 0x1000) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:            m->forwardVel = 0.0f;
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:        m->faceAngle[1] += 0x400 * sins(m->intendedYaw - m->faceAngle[1]);
src/game/mario_actions_submerged.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_GENERAL_FALL : MARIO_ANIM_FALL_FROM_WATER);
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:        m->faceAngle[1] += 0x400 * sins(m->intendedYaw - m->faceAngle[1]);
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_submerged.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_submerged.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_submerged.c:    if (m->pos[1] > m->waterLevel - 80) {
src/game/mario_actions_submerged.c:        if (m->waterLevel - 80 > m->floorHeight) {
src/game/mario_actions_submerged.c:            m->pos[1] = m->waterLevel - 80;
src/game/mario_actions_submerged.c:            if (m->action == ACT_WATER_SHELL_SWIMMING && m->heldObj != NULL) {
src/game/mario_actions_submerged.c:                m->heldObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/mario_actions_submerged.c:                m->heldObj = NULL;
src/game/mario_actions_submerged.c:    if (m->health < 0x100 && !(m->action & (ACT_FLAG_INTANGIBLE | ACT_FLAG_INVULNERABLE))) {
src/game/mario_actions_submerged.c:    m->quicksandDepth = 0.0f;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[1] = 0;
src/game/mario_actions_submerged.c:    m->marioBodyState->headAngle[2] = 0;
src/game/mario_actions_submerged.c:    switch (m->action) {
src/game/mario_actions_object.c:    if (m->action & ACT_FLAG_MOVING) {
src/game/mario_actions_object.c:    switch (m->actionArg) {
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_PUNCH_YAH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:                m->actionArg = 2;
src/game/mario_actions_object.c:                m->actionArg = 1;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.unk38.animFrame >= 2) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->actionArg == 2) {
src/game/mario_actions_object.c:                m->marioBodyState->punchState = (0 << 6) | 4;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.unk38.animFrame <= 0) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_object.c:                m->actionArg = 3;
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_PUNCH_WAH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:                m->actionArg = 5;
src/game/mario_actions_object.c:                m->actionArg = 4;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.unk38.animFrame > 0) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->actionArg == 5) {
src/game/mario_actions_object.c:                m->marioBodyState->punchState = (1 << 6) | 4;
src/game/mario_actions_object.c:            if (m->marioObj->header.gfx.unk38.animFrame <= 0) {
src/game/mario_actions_object.c:                m->flags |= MARIO_PUNCHING;
src/game/mario_actions_object.c:            if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_object.c:                m->actionArg = 6;
src/game/mario_actions_object.c:                m->marioBodyState->punchState = (2 << 6) | 6;
src/game/mario_actions_object.c:                m->flags |= MARIO_KICKING;
src/game/mario_actions_object.c:            animFrame = m->marioObj->header.gfx.unk38.animFrame;
src/game/mario_actions_object.c:                m->flags |= MARIO_TRIPPING;
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & (INPUT_NONZERO_ANALOG | INPUT_A_PRESSED | INPUT_OFF_FLOOR | INPUT_ABOVE_SLIDE)) {
src/game/mario_actions_object.c:    if (m->actionState == 0 && (m->input & INPUT_A_DOWN)) {
src/game/mario_actions_object.c:    m->actionState = 1;
src/game/mario_actions_object.c:    if (m->actionArg == 0) {
src/game/mario_actions_object.c:        m->actionTimer = 7;
src/game/mario_actions_object.c:    mario_set_forward_vel(m, sPunchingForwardVelocities[m->actionTimer]);
src/game/mario_actions_object.c:    if (m->actionTimer > 0) {
src/game/mario_actions_object.c:        m->actionTimer--;
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (m->actionState == 0 && is_anim_at_end(m)) {
src/game/mario_actions_object.c:        m->actionState = 1;
src/game/mario_actions_object.c:    if (m->actionState == 1) {
src/game/mario_actions_object.c:        if (m->heldObj->oInteractionSubtype & INT_SUBTYPE_GRABS_MARIO) {
src/game/mario_actions_object.c:            m->marioBodyState->grabPos = GRAB_POS_HEAVY_OBJ;
src/game/mario_actions_object.c:            m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (++m->actionTimer == 8) {
src/game/mario_actions_object.c:    if (m->heldObj && (m->heldObj->oInteractionSubtype & INT_SUBTYPE_HOLDABLE_NPC)) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (++m->actionTimer == 7) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (++m->actionTimer == 13) {
src/game/mario_actions_object.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_object.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_object.c:    if (m->input & INPUT_ABOVE_SLIDE) {
src/game/mario_actions_object.c:    if (m->actionState == 0) {
src/game/mario_actions_object.c:        m->actionState = 1;
src/game/mario_actions_object.c:        m->angleVel[1] = 0;
src/game/mario_actions_object.c:        m->marioBodyState->grabPos = GRAB_POS_BOWSER;
src/game/mario_actions_object.c:        play_sound(SOUND_MARIO_HRMM, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_object.c:        if (m->angleVel[1] <= -0xE00 || m->angleVel[1] >= 0xE00) {
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_SO_LONGA_BOWSER, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:            play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->angleVel[1] == 0) {
src/game/mario_actions_object.c:        if (m->actionTimer++ > 120) {
src/game/mario_actions_object.c:        m->actionTimer = 0;
src/game/mario_actions_object.c:    if (m->intendedMag > 20.0f) {
src/game/mario_actions_object.c:        if (m->actionArg == 0) {
src/game/mario_actions_object.c:            m->actionArg = 1;
src/game/mario_actions_object.c:            m->twirlYaw = m->intendedYaw;
src/game/mario_actions_object.c:            spin = (s16)(m->intendedYaw - m->twirlYaw) / 0x80;
src/game/mario_actions_object.c:            m->twirlYaw = m->intendedYaw;
src/game/mario_actions_object.c:            m->angleVel[1] += spin;
src/game/mario_actions_object.c:            if (m->angleVel[1] > 0x1000) {
src/game/mario_actions_object.c:                m->angleVel[1] = 0x1000;
src/game/mario_actions_object.c:            if (m->angleVel[1] < -0x1000) {
src/game/mario_actions_object.c:                m->angleVel[1] = -0x1000;
src/game/mario_actions_object.c:        m->actionArg = 0;
src/game/mario_actions_object.c:        m->angleVel[1] = approach_s32(m->angleVel[1], 0, 64, 64);
src/game/mario_actions_object.c:    spin = m->faceAngle[1];
src/game/mario_actions_object.c:    m->faceAngle[1] += m->angleVel[1];
src/game/mario_actions_object.c:    if (m->angleVel[1] <= -0x100 && spin < m->faceAngle[1]) {
src/game/mario_actions_object.c:        play_sound(SOUND_OBJ_BOWSER_SPINNING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->angleVel[1] >= 0x100 && spin > m->faceAngle[1]) {
src/game/mario_actions_object.c:        play_sound(SOUND_OBJ_BOWSER_SPINNING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_object.c:    if (m->angleVel[1] >= 0) {
src/game/mario_actions_object.c:        m->marioObj->header.gfx.angle[0] = -m->angleVel[1];
src/game/mario_actions_object.c:        m->marioObj->header.gfx.angle[0] = m->angleVel[1];
src/game/mario_actions_object.c:    if (++m->actionTimer == 1) {
src/game/mario_actions_object.c:        if (m->actionArg == 0) {
src/game/mario_actions_object.c:    m->angleVel[1] = 0;
src/game/mario_actions_object.c:    f32 waterSurface = m->waterLevel - 100;
src/game/mario_actions_object.c:    if (m->pos[1] < waterSurface) {
src/game/mario_actions_object.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_object.c:    if (m->health < 0x100) {
src/game/mario_actions_object.c:    switch (m->action) {
src/game/mario_actions_object.c:    if (!cancel && (m->input & INPUT_IN_WATER)) {
src/game/mario_actions_object.c:        m->particleFlags |= PARTICLE_IDLE_WATER_WAVE;
src/game/mario_actions_automatic.c:    if (m->usedObj->behavior == segmented_to_virtual(bhvTree)) {
src/game/mario_actions_automatic.c:        if (m->pos[1] - m->floorHeight > leafHeight) {
src/game/mario_actions_automatic.c:            m->particleFlags |= PARTICLE_LEAF;
src/game/mario_actions_automatic.c:    s32 isOnTree = (m->usedObj->behavior == segmented_to_virtual(bhvTree));
src/game/mario_actions_automatic.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:    f32 poleTop = m->usedObj->hitboxHeight - 100.0f;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_automatic.c:    m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_automatic.c:    m->pos[1] = m->usedObj->oPosY + marioObj->oMarioPolePos + offsetY;
src/game/mario_actions_automatic.c:    collided = f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 60.0f, 50.0f);
src/game/mario_actions_automatic.c:    collided |= f32_find_wall_collision(&m->pos[0], &m->pos[1], &m->pos[2], 30.0f, 24.0f);
src/game/mario_actions_automatic.c:    ceilHeight = vec3f_find_ceil(m->pos, m->pos[1], &ceil);
src/game/mario_actions_automatic.c:    if (m->pos[1] > ceilHeight - 160.0f) {
src/game/mario_actions_automatic.c:        m->pos[1] = ceilHeight - 160.0f;
src/game/mario_actions_automatic.c:        marioObj->oMarioPolePos = m->pos[1] - m->usedObj->oPosY;
src/game/mario_actions_automatic.c:    floorHeight = find_surface_down(m->pos[0], m->pos[1], m->pos[2], &floor);
src/game/mario_actions_automatic.c:    if (m->pos[1] < floorHeight) {
src/game/mario_actions_automatic.c:        m->pos[1] = floorHeight;
src/game/mario_actions_automatic.c:    } else if (marioObj->oMarioPolePos < -m->usedObj->hitboxDownOffset) {
src/game/mario_actions_automatic.c:        m->pos[1] = m->usedObj->oPosY - m->usedObj->hitboxDownOffset;
src/game/mario_actions_automatic.c:        if (m->pos[1] > floorHeight + 20.0f) {
src/game/mario_actions_automatic.c:            m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, m->usedObj->oMoveAnglePitch, m->faceAngle[1],
src/game/mario_actions_automatic.c:              m->usedObj->oMoveAngleRoll);
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:        m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    if ((m->input & INPUT_Z_PRESSED) || m->health < 0x100) {
src/game/mario_actions_automatic.c:        m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_automatic.c:    if (m->controller->stickY > 16.0f) {
src/game/mario_actions_automatic.c:        f32 poleTop = m->usedObj->hitboxHeight - 100.0f;
src/game/mario_actions_automatic.c:        void *poleBehavior = virtual_to_segmented(0x13, m->usedObj->behavior);
src/game/mario_actions_automatic.c:        if (poleBehavior != bhvGiantPole && m->controller->stickY > 50.0f) {
src/game/mario_actions_automatic.c:    if (m->controller->stickY < -16.0f) {
src/game/mario_actions_automatic.c:        marioObj->oMarioPoleYawVel -= m->controller->stickY * 2;
src/game/mario_actions_automatic.c:        m->faceAngle[1] += marioObj->oMarioPoleYawVel;
src/game/mario_actions_automatic.c:        if (m->usedObj->behavior == segmented_to_virtual(bhvTree)) {
src/game/mario_actions_automatic.c:            if (m->pos[1] - m->floorHeight > 100.0f) {
src/game/mario_actions_automatic.c:                m->particleFlags |= PARTICLE_LEAF;
src/game/mario_actions_automatic.c:        m->faceAngle[1] -= m->controller->stickX * 16.0f;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    s16 cameraAngle = m->area->camera->yaw;
src/game/mario_actions_automatic.c:    if (m->health < 0x100) {
src/game/mario_actions_automatic.c:        m->forwardVel = -2.0f;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_automatic.c:    if (m->controller->stickY < 8.0f) {
src/game/mario_actions_automatic.c:    marioObj->oMarioPolePos += m->controller->stickY / 8.0f;
src/game/mario_actions_automatic.c:    m->faceAngle[1] = cameraAngle - approach_s32((s16)(cameraAngle - m->faceAngle[1]), 0, 0x400, 0x400);
src/game/mario_actions_automatic.c:        sp24 = m->controller->stickY / 4.0f * 0x10000;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    m->faceAngle[1] += marioObj->oMarioPoleYawVel;
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    if (m->actionArg == 0) {
src/game/mario_actions_automatic.c:        if (m->marioObj->header.gfx.unk38.animFrame == 0) {
src/game/mario_actions_automatic.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->controller->stickY < -16.0f) {
src/game/mario_actions_automatic.c:    m->faceAngle[1] -= m->controller->stickX * 16.0f;
src/game/mario_actions_automatic.c:    m->wall = resolve_and_return_wall_collisions(nextPos, 50.0f, 50.0f);
src/game/mario_actions_automatic.c:    nextPos[1] = m->ceilHeight - 160.0f;
src/game/mario_actions_automatic.c:    vec3f_copy(m->pos, nextPos);
src/game/mario_actions_automatic.c:    m->floor = floor;
src/game/mario_actions_automatic.c:    m->floorHeight = floorHeight;
src/game/mario_actions_automatic.c:    m->ceil = ceil;
src/game/mario_actions_automatic.c:    m->ceilHeight = ceilHeight;
src/game/mario_actions_automatic.c:    m->forwardVel += 1.0f;
src/game/mario_actions_automatic.c:    if (m->forwardVel > maxSpeed) {
src/game/mario_actions_automatic.c:        m->forwardVel = maxSpeed;
src/game/mario_actions_automatic.c:    m->faceAngle[1] =
src/game/mario_actions_automatic.c:        m->intendedYaw - approach_s32((s16)(m->intendedYaw - m->faceAngle[1]), 0, 0x800, 0x800);
src/game/mario_actions_automatic.c:    m->slideYaw = m->faceAngle[1];
src/game/mario_actions_automatic.c:    m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->vel[0] = m->slideVelX;
src/game/mario_actions_automatic.c:    m->vel[1] = 0.0f;
src/game/mario_actions_automatic.c:    m->vel[2] = m->slideVelZ;
src/game/mario_actions_automatic.c:    nextPos[0] = m->pos[0] - m->ceil->normal.y * m->vel[0];
src/game/mario_actions_automatic.c:    nextPos[2] = m->pos[2] - m->ceil->normal.y * m->vel[2];
src/game/mario_actions_automatic.c:    nextPos[1] = m->pos[1];
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_automatic.c:    m->forwardVel = 0.0f;
src/game/mario_actions_automatic.c:    m->slideVelX = 0.0f;
src/game/mario_actions_automatic.c:    m->slideVelZ = 0.0f;
src/game/mario_actions_automatic.c:    m->pos[1] = m->ceilHeight - 160.0f;
src/game/mario_actions_automatic.c:    vec3f_copy(m->vel, gVec3fZero);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    if (m->actionTimer++ == 0) {
src/game/mario_actions_automatic.c:    m->actionTimer++;
src/game/mario_actions_automatic.c:    if ((m->input & INPUT_NONZERO_ANALOG) && m->actionTimer >= 31) {
src/game/mario_actions_automatic.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->ceil->type != SURFACE_HANGABLE) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_automatic.c:        return set_mario_action(m, ACT_HANG_MOVING, m->actionArg);
src/game/mario_actions_automatic.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->ceil->type != SURFACE_HANGABLE) {
src/game/mario_actions_automatic.c:    if (m->actionArg & 1) {
src/game/mario_actions_automatic.c:    if (!(m->input & INPUT_A_DOWN)) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_automatic.c:    if (m->ceil->type != SURFACE_HANGABLE) {
src/game/mario_actions_automatic.c:    if (m->actionArg & 1) {
src/game/mario_actions_automatic.c:    if (m->marioObj->header.gfx.unk38.animFrame == 12) {
src/game/mario_actions_automatic.c:        play_sound(SOUND_ACTION_HANGING_STEP, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:        m->actionArg ^= 1;
src/game/mario_actions_automatic.c:        if (m->input & INPUT_UNKNOWN_5) {
src/game/mario_actions_automatic.c:            return set_mario_action(m, ACT_HANGING, m->actionArg);
src/game/mario_actions_automatic.c:    m->vel[1] = 0.0f;
src/game/mario_actions_automatic.c:    m->forwardVel = -8.0f;
src/game/mario_actions_automatic.c:    m->pos[0] -= 60.0f * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->pos[2] -= 60.0f * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    floorHeight = find_surface_down(m->pos[0], m->pos[1], m->pos[2], &floor);
src/game/mario_actions_automatic.c:    if (floorHeight < m->pos[1] - 100.0f) {
src/game/mario_actions_automatic.c:        m->pos[1] -= 100.0f;
src/game/mario_actions_automatic.c:        m->pos[1] = floorHeight;
src/game/mario_actions_automatic.c:    m->pos[0] += 14.0f * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->pos[2] += 14.0f * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    if (m->actionTimer < 14) {
src/game/mario_actions_automatic.c:        sp4 = m->actionTimer;
src/game/mario_actions_automatic.c:    m->statusForCamera->pos[0] = m->pos[0] + sp4 * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->statusForCamera->pos[2] = m->pos[2] + sp4 * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:    m->statusForCamera->pos[1] = m->pos[1];
src/game/mario_actions_automatic.c:    m->actionTimer++;
src/game/mario_actions_automatic.c:    m->flags |= MARIO_UNKNOWN_25;
src/game/mario_actions_automatic.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_automatic.c:    s32 hasSpaceForMario = (m->ceilHeight - m->floorHeight >= 160.0f);
src/game/mario_actions_automatic.c:    if (m->actionTimer < 10) {
src/game/mario_actions_automatic.c:        m->actionTimer++;
src/game/mario_actions_automatic.c:    if (m->floor->normal.y < 0.9063078f) {
src/game/mario_actions_automatic.c:    if (m->input & (INPUT_Z_PRESSED | INPUT_OFF_FLOOR)) {
src/game/mario_actions_automatic.c:    if ((m->input & INPUT_A_PRESSED) && hasSpaceForMario) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_UNKNOWN_10) {
src/game/mario_actions_automatic.c:        if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK1) {
src/game/mario_actions_automatic.c:            m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/mario_actions_automatic.c:    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG) && !(m->input & INPUT_A_DOWN))
src/game/mario_actions_automatic.c:    if (m->actionTimer == 10 && (m->input & INPUT_NONZERO_ANALOG))
src/game/mario_actions_automatic.c:    heightAboveFloor = m->pos[1] - find_floor_height_relative_polar(m, -0x8000, 30.0f);
src/game/mario_actions_automatic.c:    if (m->actionArg == 0) {
src/game/mario_actions_automatic.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_automatic.c:    if (m->actionTimer >= 28
src/game/mario_actions_automatic.c:        && (m->input
src/game/mario_actions_automatic.c:    if (m->actionTimer == 10) {
src/game/mario_actions_automatic.c:    if (m->marioObj->header.gfx.unk38.animFrame == 17) {
src/game/mario_actions_automatic.c:        m->action = ACT_LEDGE_CLIMB_SLOW_2;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_automatic.c:    m->actionArg = 1;
src/game/mario_actions_automatic.c:    if (m->input & INPUT_OFF_FLOOR) {
src/game/mario_actions_automatic.c:    if (m->marioObj->header.gfx.unk38.animFrame == 8) {
src/game/mario_actions_automatic.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK2) {
src/game/mario_actions_automatic.c:        s32 thrown = (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK6) == 0;
src/game/mario_actions_automatic.c:        m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_automatic.c:        vec3f_copy(m->pos, m->marioObj->header.gfx.pos);
src/game/mario_actions_automatic.c:        return set_mario_action(m, (m->forwardVel >= 0.0f) ? ACT_THROWN_FORWARD : ACT_THROWN_BACKWARD,
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    s16 startFacePitch = m->faceAngle[0];
src/game/mario_actions_automatic.c:    s16 startFaceYaw = m->faceAngle[1];
src/game/mario_actions_automatic.c:    switch (m->actionState) {
src/game/mario_actions_automatic.c:            m->marioObj->header.gfx.node.flags &= ~GRAPH_RENDER_ACTIVE;
src/game/mario_actions_automatic.c:            m->usedObj->oInteractStatus = INT_STATUS_INTERACTED;
src/game/mario_actions_automatic.c:            m->statusForCamera->cameraEvent = CAM_EVENT_CANNON;
src/game/mario_actions_automatic.c:            m->statusForCamera->usedObj = m->usedObj;
src/game/mario_actions_automatic.c:            vec3f_set(m->vel, 0.0f, 0.0f, 0.0f);
src/game/mario_actions_automatic.c:            m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_automatic.c:            m->pos[1] = m->usedObj->oPosY + 350.0f;
src/game/mario_actions_automatic.c:            m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_automatic.c:            m->forwardVel = 0.0f;
src/game/mario_actions_automatic.c:            m->actionState = 1;
src/game/mario_actions_automatic.c:            if (m->usedObj->oAction == 1) {
src/game/mario_actions_automatic.c:                m->faceAngle[0] = m->usedObj->oMoveAnglePitch;
src/game/mario_actions_automatic.c:                m->faceAngle[1] = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_automatic.c:                marioObj->oMarioCannonObjectYaw = m->usedObj->oMoveAngleYaw;
src/game/mario_actions_automatic.c:                m->actionState = 2;
src/game/mario_actions_automatic.c:            m->faceAngle[0] -= (s16)(m->controller->stickY * 10.0f);
src/game/mario_actions_automatic.c:            marioObj->oMarioCannonInputYaw -= (s16)(m->controller->stickX * 10.0f);
src/game/mario_actions_automatic.c:            if (m->faceAngle[0] > 0x38E3) {
src/game/mario_actions_automatic.c:                m->faceAngle[0] = 0x38E3;
src/game/mario_actions_automatic.c:            if (m->faceAngle[0] < 0) {
src/game/mario_actions_automatic.c:                m->faceAngle[0] = 0;
src/game/mario_actions_automatic.c:            m->faceAngle[1] = marioObj->oMarioCannonObjectYaw + marioObj->oMarioCannonInputYaw;
src/game/mario_actions_automatic.c:            if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_automatic.c:                m->forwardVel = 100.0f * coss(m->faceAngle[0]);
src/game/mario_actions_automatic.c:                m->vel[1] = 100.0f * sins(m->faceAngle[0]);
src/game/mario_actions_automatic.c:                m->pos[0] += 120.0f * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_automatic.c:                m->pos[1] += 120.0f * sins(m->faceAngle[0]);
src/game/mario_actions_automatic.c:                m->pos[2] += 120.0f * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_automatic.c:                play_sound(SOUND_ACTION_FLYING_FAST, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:                play_sound(SOUND_OBJ_POUNDING_CANNON, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:                m->marioObj->header.gfx.node.flags |= GRAPH_RENDER_ACTIVE;
src/game/mario_actions_automatic.c:                m->usedObj->oAction = 2;
src/game/mario_actions_automatic.c:                if (m->faceAngle[0] != startFacePitch || m->faceAngle[1] != startFaceYaw) {
src/game/mario_actions_automatic.c:                    play_sound(SOUND_MOVING_AIM_CANNON, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1], 0);
src/game/mario_actions_automatic.c:    struct Object *marioObj = m->marioObj;
src/game/mario_actions_automatic.c:    struct Object *usedObj = m->usedObj;
src/game/mario_actions_automatic.c:    s16 prevTwirlYaw = m->twirlYaw;
src/game/mario_actions_automatic.c:    f32 dx = (m->pos[0] - usedObj->oPosX) * 0.95f;
src/game/mario_actions_automatic.c:    f32 dz = (m->pos[2] - usedObj->oPosZ) * 0.95f;
src/game/mario_actions_automatic.c:    if (m->vel[1] < 60.0f) {
src/game/mario_actions_automatic.c:        m->vel[1] += 1.0f;
src/game/mario_actions_automatic.c:    if ((marioObj->oMarioTornadoPosY += m->vel[1]) < 0.0f) {
src/game/mario_actions_automatic.c:        if (m->vel[1] < 20.0f) {
src/game/mario_actions_automatic.c:            m->vel[1] = 20.0f;
src/game/mario_actions_automatic.c:    if (m->angleVel[1] < 0x3000) {
src/game/mario_actions_automatic.c:        m->angleVel[1] += 0x100;
src/game/mario_actions_automatic.c:    m->twirlYaw += m->angleVel[1];
src/game/mario_actions_automatic.c:        m->floor = floor;
src/game/mario_actions_automatic.c:        m->floorHeight = floorHeight;
src/game/mario_actions_automatic.c:        vec3f_copy(m->pos, nextPos);
src/game/mario_actions_automatic.c:        if (nextPos[1] >= m->floorHeight) {
src/game/mario_actions_automatic.c:            m->pos[1] = nextPos[1];
src/game/mario_actions_automatic.c:            m->pos[1] = m->floorHeight;
src/game/mario_actions_automatic.c:    m->actionTimer++;
src/game/mario_actions_automatic.c:    set_mario_animation(m, (m->actionArg == 0) ? MARIO_ANIM_START_TWIRL : MARIO_ANIM_TWIRL);
src/game/mario_actions_automatic.c:        m->actionArg = 1;
src/game/mario_actions_automatic.c:    if (prevTwirlYaw > m->twirlYaw) {
src/game/mario_actions_automatic.c:        play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_automatic.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_automatic.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, m->faceAngle[1] + m->twirlYaw, 0);
src/game/mario_actions_automatic.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_automatic.c:    m->quicksandDepth = 0.0f;
src/game/mario_actions_automatic.c:    switch (m->action) {
src/game/obj_behaviors_2.c: * However, most objects that use this function handle the far-from-home case
src/game/interaction.c:    f32 dx = m->pos[0] - o->oPosX;
src/game/interaction.c:    f32 dz = m->pos[2] - o->oPosZ;
src/game/interaction.c:    f32 dx = o->oPosX - m->pos[0];
src/game/interaction.c:    f32 dz = o->oPosZ - m->pos[2];
src/game/interaction.c:    u32 action = m->action;
src/game/interaction.c:            s16 dYawToObject = mario_obj_angle_to_object(m, o) - m->faceAngle[1];
src/game/interaction.c:            if (m->flags & MARIO_PUNCHING) {
src/game/interaction.c:            if (m->flags & MARIO_KICKING) {
src/game/interaction.c:            if (m->flags & MARIO_TRIPPING) {
src/game/interaction.c:            if (m->vel[1] < 0.0f) {
src/game/interaction.c:            if (m->vel[1] < 0.0f && m->actionState == 0) {
src/game/interaction.c:        } else if (m->forwardVel <= -26.0f || 26.0f <= m->forwardVel) {
src/game/interaction.c:        if (m->vel[1] < 0.0f) {
src/game/interaction.c:            if (m->pos[1] > o->oPosY) {
src/game/interaction.c:            if (m->pos[1] < o->oPosY) {
src/game/interaction.c:    if (m->riddenObj != NULL) {
src/game/interaction.c:        m->riddenObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/interaction.c:        m->riddenObj = NULL;
src/game/interaction.c:    if (m->heldObj == NULL) {
src/game/interaction.c:        m->heldObj = m->usedObj;
src/game/interaction.c:        obj_set_held_state(m->heldObj, bhvCarrySomething3);
src/game/interaction.c:    if (m->heldObj != NULL) {
src/game/interaction.c:        if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
src/game/interaction.c:        obj_set_held_state(m->heldObj, bhvCarrySomething4);
src/game/interaction.c:        m->heldObj->oPosX = m->marioBodyState->heldObjLastPosition[0];
src/game/interaction.c:        m->heldObj->oPosY = m->pos[1];
src/game/interaction.c:        m->heldObj->oPosZ = m->marioBodyState->heldObjLastPosition[2];
src/game/interaction.c:        m->heldObj->oMoveAngleYaw = m->faceAngle[1];
src/game/interaction.c:        m->heldObj = NULL;
src/game/interaction.c:    if (m->heldObj != NULL) {
src/game/interaction.c:        if (m->heldObj->behavior == segmented_to_virtual(bhvKoopaShellUnderwater)) {
src/game/interaction.c:        obj_set_held_state(m->heldObj, bhvCarrySomething5);
src/game/interaction.c:        m->heldObj->oPosX = m->marioBodyState->heldObjLastPosition[0] + 32.0f * sins(m->faceAngle[1]);
src/game/interaction.c:        m->heldObj->oPosY = m->marioBodyState->heldObjLastPosition[1];
src/game/interaction.c:        m->heldObj->oPosZ = m->marioBodyState->heldObjLastPosition[2] + 32.0f * coss(m->faceAngle[1]);
src/game/interaction.c:        m->heldObj->oMoveAngleYaw = m->faceAngle[1];
src/game/interaction.c:        m->heldObj = NULL;
src/game/interaction.c:    if (m->action == ACT_RIDING_HOOT) {
src/game/interaction.c:        m->usedObj->oInteractStatus = 0;
src/game/interaction.c:        m->usedObj->oHootMarioReleaseTime = gGlobalTimer;
src/game/interaction.c:    return (m->flags & MARIO_CAP_FLAGS) == (MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
src/game/interaction.c:        save_file_set_cap_pos(m->pos[0], m->pos[1], m->pos[2]);
src/game/interaction.c:        m->flags &= ~(MARIO_NORMAL_CAP | MARIO_CAP_ON_HEAD);
src/game/interaction.c:        capObject = spawn_object(m->marioObj, MODEL_MARIOS_CAP, bhvNormalCap);
src/game/interaction.c:        capObject->oPosY += (m->action & ACT_FLAG_SHORT_HITBOX) ? 120.0f : 180.0f;
src/game/interaction.c:        capObject->oMoveAngleYaw = (s16)(m->faceAngle[1] + 0x400);
src/game/interaction.c:        if (m->forwardVel < 0.0f) {
src/game/interaction.c:    u32 action = m->action;
src/game/interaction.c:        if (m->actionArg < 2) {
src/game/interaction.c:    for (i = 0; i < m->marioObj->numCollidedObjs; i++) {
src/game/interaction.c:        object = m->marioObj->collidedObjs[i];
src/game/interaction.c:    if (m->input & INPUT_INTERACT_OBJ_GRABBABLE) {
src/game/interaction.c:        script = virtual_to_segmented(0x13, m->interactObj->behavior);
src/game/interaction.c:            s16 facingDYaw = m->faceAngle[1] - m->interactObj->oMoveAngleYaw;
src/game/interaction.c:                m->faceAngle[1] = m->interactObj->oMoveAngleYaw;
src/game/interaction.c:                m->usedObj = m->interactObj;
src/game/interaction.c:            s16 facingDYaw = mario_obj_angle_to_object(m, m->interactObj) - m->faceAngle[1];
src/game/interaction.c:                m->usedObj = m->interactObj;
src/game/interaction.c:                if (!(m->action & ACT_FLAG_AIR)) {
src/game/interaction.c:                        m, (m->action & ACT_FLAG_DIVING) ? ACT_DIVE_PICKING_UP : ACT_PICKING_UP, 0);
src/game/interaction.c:    m->pos[1] = o->oPosY + o->hitboxHeight;
src/game/interaction.c:    m->vel[1] = velY;
src/game/interaction.c:    m->flags &= ~MARIO_UNKNOWN_08;
src/game/interaction.c:    play_sound(SOUND_ACTION_BOUNCE_OFF_OBJECT, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    m->vel[1] = 0.0f;
src/game/interaction.c:    s16 angleToObject = mario_obj_angle_to_object(m, m->interactObj);
src/game/interaction.c:    s16 facingDYaw = angleToObject - m->faceAngle[1];
src/game/interaction.c:    if (m->forwardVel < 16.0f) {
src/game/interaction.c:        m->forwardVel = 16.0f;
src/game/interaction.c:    m->faceAngle[1] = angleToObject;
src/game/interaction.c:        m->forwardVel *= -1.0f;
src/game/interaction.c:        if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
src/game/interaction.c:        m->faceAngle[1] += 0x8000;
src/game/interaction.c:        if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
src/game/interaction.c:    s16 angleToObject = mario_obj_angle_to_object(m, m->interactObj);
src/game/interaction.c:    s16 facingDYaw = angleToObject - m->faceAngle[1];
src/game/interaction.c:    s16 remainingHealth = m->health - 0x40 * m->hurtCounter;
src/game/interaction.c:    if (m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER)) {
src/game/interaction.c:    } else if (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) {
src/game/interaction.c:    } else if (m->interactObj->oDamageOrCoinValue >= 4) {
src/game/interaction.c:    } else if (m->interactObj->oDamageOrCoinValue >= 2) {
src/game/interaction.c:    m->faceAngle[1] = angleToObject;
src/game/interaction.c:        if (m->forwardVel < 28.0f) {
src/game/interaction.c:        if (m->pos[1] >= m->interactObj->oPosY) {
src/game/interaction.c:            if (m->vel[1] < 20.0f) {
src/game/interaction.c:                m->vel[1] = 20.0f;
src/game/interaction.c:            if (m->vel[1] > 0.0f) {
src/game/interaction.c:                m->vel[1] = 0.0f;
src/game/interaction.c:        if (m->forwardVel < 16.0f) {
src/game/interaction.c:        m->forwardVel *= -1.0f;
src/game/interaction.c:        m->faceAngle[1] += 0x8000;
src/game/interaction.c:    f32 minDistance = o->hitboxRadius + m->marioObj->hitboxRadius + padding;
src/game/interaction.c:    f32 offsetX = m->pos[0] - o->oPosX;
src/game/interaction.c:    f32 offsetZ = m->pos[2] - o->oPosZ;
src/game/interaction.c:            pushAngle = m->faceAngle[1];
src/game/interaction.c:        f32_find_wall_collision(&newMarioX, &m->pos[1], &newMarioZ, 60.0f, 50.0f);
src/game/interaction.c:        find_surface_down(newMarioX, m->pos[1], newMarioZ, &floor);
src/game/interaction.c:            m->pos[0] = newMarioX;
src/game/interaction.c:            m->pos[2] = newMarioZ;
src/game/interaction.c:        if (m->action == ACT_PUNCHING) {
src/game/interaction.c:            m->action = ACT_MOVE_PUNCHING;
src/game/interaction.c:        if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:        m->particleFlags |= PARTICLE_TRIANGLE;
src/game/interaction.c:        play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    f32 dx = o->oPosX - m->pos[0];
src/game/interaction.c:    f32 dz = o->oPosZ - m->pos[2];
src/game/interaction.c:    s32 damage = m->interactObj->oDamageOrCoinValue;
src/game/interaction.c:    if (!(m->flags & MARIO_CAP_ON_HEAD)) {
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:    m->hurtCounter += 4 * damage;
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:            m->forwardVel = 40.0f;
src/game/interaction.c:            play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->action == ACT_WATER_JUMP || m->action == ACT_SHOT_FROM_CANNON || m->action == ACT_FLYING) {
src/game/interaction.c:        set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/interaction.c:        m->faceAngle[0] = 0;
src/game/interaction.c:    m->numCoins += o->oDamageOrCoinValue;
src/game/interaction.c:    m->healCounter += 4 * o->oDamageOrCoinValue;
src/game/interaction.c:    if (COURSE_IS_MAIN_COURSE(gCurrCourseNum) && m->numCoins - o->oDamageOrCoinValue < 100
src/game/interaction.c:        && m->numCoins >= 100) {
src/game/interaction.c:    m->healCounter += 4 * o->oDamageOrCoinValue;
src/game/interaction.c:    if (m->health >= 0x100) {
src/game/interaction.c:            m->hurtCounter = 0;
src/game/interaction.c:            m->healCounter = 0;
src/game/interaction.c:            if (m->capTimer > 1) {
src/game/interaction.c:                m->capTimer = 1;
src/game/interaction.c:        if (m->action & ACT_FLAG_SWIMMING) {
src/game/interaction.c:        if (m->action & ACT_FLAG_METAL_WATER) {
src/game/interaction.c:        if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        save_file_collect_star_or_key(m->numCoins, starIndex);
src/game/interaction.c:        m->numStars =
src/game/interaction.c:        play_sound(SOUND_MENU_STAR_SOUND, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->action != ACT_BBH_ENTER_SPIN && m->action != ACT_BBH_ENTER_JUMP) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:        action = m->action;
src/game/interaction.c:                m->interactObj = o;
src/game/interaction.c:                m->usedObj = o;
src/game/interaction.c:        if (m->action != ACT_EMERGE_FROM_PIPE) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:                play_sound(SOUND_MENU_ENTER_PIPE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:                play_sound(SOUND_MENU_ENTER_HOLE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:                       m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->action == ACT_WALKING || m->action == ACT_DECELERATING) {
src/game/interaction.c:        if (m->action == ACT_WALKING || m->action == ACT_DECELERATING) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    if (m->action == ACT_WALKING || m->action == ACT_DECELERATING) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    } else if (m->action == ACT_IDLE && sDisplayingDoorText == TRUE && requiredNumStars == 70) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:    if (m->action != ACT_IN_CANNON) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:    m->interactObj = o;
src/game/interaction.c:    m->usedObj = o;
src/game/interaction.c:    struct Object *marioObj = m->marioObj;
src/game/interaction.c:    if (m->action != ACT_TORNADO_TWIRLING && m->action != ACT_SQUISHED) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        marioObj->oMarioTornadoPosY = m->pos[1] - o->oPosY;
src/game/interaction.c:        play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        return set_mario_action(m, ACT_TORNADO_TWIRLING, m->action == ACT_TWIRLING);
src/game/interaction.c:    struct Object *marioObj = m->marioObj;
src/game/interaction.c:    if (m->action != ACT_CAUGHT_IN_WHIRLPOOL) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        m->forwardVel = 0.0f;
src/game/interaction.c:        marioObj->oMarioWhirlpoolPosY = m->pos[1] - o->oPosY;
src/game/interaction.c:        play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    UNUSED struct Object *marioObj = m->marioObj;
src/game/interaction.c:    if (m->action != ACT_GETTING_BLOWN) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:        m->faceAngle[1] = o->oMoveAngleYaw + 0x8000;
src/game/interaction.c:        m->unkC4 = 0.4f;
src/game/interaction.c:        m->forwardVel = -24.0f;
src/game/interaction.c:        m->vel[1] = 12.0f;
src/game/interaction.c:        play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_METAL_CAP) && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        if ((m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER))
src/game/interaction.c:            || m->waterLevel - m->pos[1] > 50.0f) {
src/game/interaction.c:            play_sound(SOUND_GENERAL_FLAME_OUT, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            m->marioObj->oMarioBurnTimer = 0;
src/game/interaction.c:            play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            if ((m->action & ACT_FLAG_AIR) && m->vel[1] <= 0.0f) {
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)) {
src/game/interaction.c:        if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:            play_sound(SOUND_ACTION_UNKNOWN458, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:    m->interactObj = o;
src/game/interaction.c:        m->forwardVel = -16.0f;
src/game/interaction.c:        o->oMoveAngleYaw = m->faceAngle[1];
src/game/interaction.c:    else if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        m->invincTimer = 2;
src/game/interaction.c:        play_sound(SOUND_MARIO_EEUH, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        play_sound(SOUND_OBJ_BULLY_METAL, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (!sInvulnerable && !(m->flags & MARIO_VANISH_CAP)
src/game/interaction.c:        u32 actionArg = (m->action & (ACT_FLAG_AIR | ACT_FLAG_ON_POLE | ACT_FLAG_HANGING)) == 0;
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        if (m->action & (ACT_FLAG_SWIMMING | ACT_FLAG_METAL_WATER)) {
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:                play_sound(SOUND_MARIO_TWIRL_BOUNCE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (m->flags & MARIO_METAL_CAP) {
src/game/interaction.c:                play_sound(SOUND_MARIO_TWIRL_BOUNCE, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:    if (!(m->action & ACT_FLAG_RIDING_SHELL)) {
src/game/interaction.c:        if (interaction == INT_HIT_FROM_ABOVE || m->action == ACT_WALKING
src/game/interaction.c:            || m->action == ACT_HOLD_WALKING) {
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:            m->riddenObj = o;
src/game/interaction.c:    if ((!(m->action & (ACT_FLAG_AIR | ACT_FLAG_INVULNERABLE | ACT_FLAG_ATTACKING)) || !sInvulnerable)
src/game/interaction.c:            m->faceAngle[1] = o->oMoveAngleYaw;
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:            play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    s32 actionId = m->action & ACT_ID_MASK;
src/game/interaction.c:        if (!(m->prevAction & ACT_FLAG_ON_POLE) || m->usedObj != o) {
src/game/interaction.c:            f32 velConv = m->forwardVel; // conserve the velocity.
src/game/interaction.c:            struct Object *marioObj = m->marioObj;
src/game/interaction.c:            u32 lowSpeed = (m->forwardVel <= 10.0f);
src/game/interaction.c:            struct Object *marioObj = m->marioObj;
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:            m->vel[1] = 0.0f;
src/game/interaction.c:            m->forwardVel = 0.0f;
src/game/interaction.c:            marioObj->oMarioPolePos = m->pos[1] - o->oPosY;
src/game/interaction.c:            //! @bug Using m->forwardVel here is assumed to be 0.0f due to the set from earlier.
src/game/interaction.c:            marioObj->oMarioPoleYawVel = (s32)(m->forwardVel * 0x100 + 0x1000);
src/game/interaction.c:    s32 actionId = m->action & ACT_ID_MASK;
src/game/interaction.c:        && (gGlobalTimer - m->usedObj->oHootMarioReleaseTime > 30)) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->usedObj = o;
src/game/interaction.c:    if (m->action != ACT_GETTING_BLOWN && capFlag != 0) {
src/game/interaction.c:        m->interactObj = o;
src/game/interaction.c:        m->flags &= ~MARIO_CAP_ON_HEAD & ~MARIO_CAP_IN_HAND;
src/game/interaction.c:        m->flags |= capFlag;
src/game/interaction.c:        if (capTime > m->capTimer) {
src/game/interaction.c:            m->capTimer = capTime;
src/game/interaction.c:        if ((m->action & ACT_FLAG_IDLE) || m->action == ACT_WALKING) {
src/game/interaction.c:            m->flags |= MARIO_CAP_IN_HAND;
src/game/interaction.c:            m->flags |= MARIO_CAP_ON_HEAD;
src/game/interaction.c:        play_sound(SOUND_MENU_STAR_SOUND, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->input |= INPUT_INTERACT_OBJ_GRABBABLE;
src/game/interaction.c:    if ((m->action & ACT_FLAG_IDLE) != 0x00000000) {
src/game/interaction.c:    if (m->action == ACT_WALKING) {
src/game/interaction.c:        val6 = m->marioObj->header.gfx.unk38.animID;
src/game/interaction.c:    if ((m->input & READ_MASK) && mario_can_talk(m, 0) && object_facing_mario(m, o, SIGN_RANGE)) {
src/game/interaction.c:        s16 facingDYaw = (s16)(o->oMoveAngleYaw + 0x8000) - m->faceAngle[1];
src/game/interaction.c:            m->marioObj->oMarioReadingSignDYaw = facingDYaw;
src/game/interaction.c:            m->marioObj->oMarioReadingSignDPosX = targetX - m->pos[0];
src/game/interaction.c:            m->marioObj->oMarioReadingSignDPosZ = targetZ - m->pos[2];
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    if ((m->input & READ_MASK) && mario_can_talk(m, 1)) {
src/game/interaction.c:        s16 facingDYaw = mario_obj_angle_to_object(m, o) - m->faceAngle[1];
src/game/interaction.c:            m->interactObj = o;
src/game/interaction.c:            m->usedObj = o;
src/game/interaction.c:    if (m->flags & (MARIO_PUNCHING | MARIO_KICKING | MARIO_TRIPPING)) {
src/game/interaction.c:        detector[0] = m->pos[0] + 50.0f * sins(m->faceAngle[1]);
src/game/interaction.c:        detector[2] = m->pos[2] + 50.0f * coss(m->faceAngle[1]);
src/game/interaction.c:        detector[1] = m->pos[1];
src/game/interaction.c:            if (m->action != ACT_MOVE_PUNCHING || m->forwardVel >= 0.0f) {
src/game/interaction.c:                if (m->action == ACT_PUNCHING) {
src/game/interaction.c:                    m->action = ACT_MOVE_PUNCHING;
src/game/interaction.c:                play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:                m->particleFlags |= PARTICLE_TRIANGLE;
src/game/interaction.c:            } else if (m->action & ACT_FLAG_AIR) {
src/game/interaction.c:                play_sound(SOUND_ACTION_HIT_2, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:                m->particleFlags |= PARTICLE_TRIANGLE;
src/game/interaction.c:    sInvulnerable = (m->action & ACT_FLAG_INVULNERABLE) || m->invincTimer != 0;
src/game/interaction.c:    if (!(m->action & ACT_FLAG_INTANGIBLE) && m->collidedObjInteractTypes != 0) {
src/game/interaction.c:            if (m->collidedObjInteractTypes & interactType) {
src/game/interaction.c:                m->collidedObjInteractTypes &= ~interactType;
src/game/interaction.c:    if (m->invincTimer > 0 && !sDelayInvincTimer) {
src/game/interaction.c:        m->invincTimer -= 1;
src/game/interaction.c:    m->flags &= ~MARIO_PUNCHING & ~MARIO_KICKING & ~MARIO_TRIPPING;
src/game/interaction.c:    if (!(m->marioObj->collidedObjInteractTypes & (INTERACT_WARP_DOOR | INTERACT_DOOR))) {
src/game/interaction.c:    if (!(m->marioObj->collidedObjInteractTypes & INTERACT_WARP)) {
src/game/interaction.c:    if (m->pos[1] < m->floorHeight + 2048.0f) {
src/game/interaction.c:        if (level_trigger_warp(m, WARP_OP_WARP_FLOOR) == 20 && !(m->flags & MARIO_UNKNOWN_18)) {
src/game/interaction.c:            play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/interaction.c:    if (!(m->action & ACT_FLAG_RIDING_SHELL) && m->pos[1] < m->floorHeight + 10.0f) {
src/game/interaction.c:        if (!(m->flags & MARIO_METAL_CAP)) {
src/game/interaction.c:            m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/interaction.c:            m->marioObj->oBehParams = (1 << 24);
src/game/interaction.c:    if ((m->action & ACT_GROUP_MASK) == ACT_GROUP_CUTSCENE) {
src/game/interaction.c:    if (m->floor != NULL) {
src/game/interaction.c:        s32 floorType = m->floor->type;
src/game/interaction.c:        if (!(m->action & ACT_FLAG_AIR) && !(m->action & ACT_FLAG_SWIMMING)) {
src/game/level_geo.c:        gfx = create_skybox_facing_camera(0, backgroundNode->background, camFrustum->fov, gLakituState.pos[0],
src/game/rendering_graph_node.c:    if (anim->flags & ANIM_FLAG_HOR_TRANS) {
src/game/rendering_graph_node.c:    } else if (anim->flags & ANIM_FLAG_VERT_TRANS) {
src/game/rendering_graph_node.c:    } else if (anim->flags & ANIM_FLAG_6) {
src/game/rendering_graph_node.c:    gCurAnimEnabled = (anim->flags & ANIM_FLAG_5) == 0;
src/game/rendering_graph_node.c:    gCurrAnimAttribute = segmented_to_virtual((void *) anim->index);
src/game/rendering_graph_node.c:    gCurAnimData = segmented_to_virtual((void *) anim->values);
src/game/rendering_graph_node.c:    if (anim->unk02 == 0) {
src/game/rendering_graph_node.c:        gCurAnimTranslationMultiplier = (f32) node->animYTrans / (f32) anim->unk02;
src/game/rendering_graph_node.c:    halfFov = (gCurGraphNodeCamFrustum->fov / 2.0f + 1.0f) * 32768.0f / 180.0f + 0.5f;
src/game/behaviors/bowser.inc.c:        if (bowser->header.gfx.unk38.curAnim->unk08 == sp30)
src/game/behaviors/bowser.inc.c:    platform->oAngleVelPitch = coss(angle) * a1;
src/game/behaviors/bowser.inc.c:    platform->oAngleVelRoll = -sins(angle) * a1;
src/game/behaviors/bowser.inc.c:                    play_sound(SOUND_ENV_UNKNOWN4, platform->header.gfx.cameraToObject);
src/game/behaviors/bowser.inc.c:            platform->oAngleVelPitch = 0;
src/game/behaviors/bowser.inc.c:            platform->oAngleVelRoll = 0;
src/game/behaviors/bowser.inc.c:            platform->oFaceAnglePitch = 0;
src/game/behaviors/bowser.inc.c:            platform->oFaceAngleRoll = 0;
src/game/behaviors/tower_platform.inc.c:    platform->oMoveAngleYaw = yaw;
src/game/behaviors/tower_platform.inc.c:    platform->oPosX += o->oPlatformSpawnerUnk100 * sins(yaw);
src/game/behaviors/tower_platform.inc.c:    platform->oPosY += 100 * o->oPlatformSpawnerUnkF4;
src/game/behaviors/tower_platform.inc.c:    platform->oPosZ += o->oPlatformSpawnerUnk100 * coss(yaw);
src/game/behaviors/tower_platform.inc.c:    platform->oPlatformUnk110 = o->oPlatformSpawnerUnk104;
src/game/behaviors/tower_platform.inc.c:    platform->oPlatformUnk10C = o->oPlatformSpawnerUnk108;
src/game/behaviors/ferris_wheel.inc.c:            platform->collisionData =
src/game/behaviors/piranha_bubbles.inc.c:    s32 lastFrame = parent->header.gfx.unk38.curAnim->unk08 - 2;
src/game/behaviors/flagpole.inc.c:	if (m->interactObj == o) {
src/game/behaviors/flagpole.inc.c:	f32 topPole = abs(o->hitboxHeight - m->pos[1]);
src/game/behaviors/flagpole.inc.c:		spawn_object(m->marioObj, MODEL_1UP, bhv1Up);
src/game/behaviors/flagpole.inc.c:		if (m->actionArg==0)
src/game/behaviors/flagpole.inc.c:	m->marioObj->oMarioPolePos -= 28.0f;
src/game/behaviors/flagpole.inc.c:	if (!(m->action & ACT_WALL_KICK_AIR) && ((m->pos[1] - m->floorHeight) < 20) ) {
src/game/behaviors/flagpole.inc.c:		m->faceAngle[1]+=0x8000;
src/game/behaviors/flagpole.inc.c:	if (m->action & ACT_HOLDING_POLE) {
src/game/behaviors/flagpole.inc.c:		m->faceAngle[1]+=0x8000;
src/game/behaviors/flagpole.inc.c:	if (m->action & ACT_WALL_KICK_AIR) {
src/game/behaviors/flagpole.inc.c:	if (m->interactObj == o) {
src/game/behaviors/flagpole.inc.c:		if (m->pos[1] - m->floorHeight < 20.0f) {
src/game/behaviors/flagpole.inc.c:			if (m->vel[1] < 0) {
src/game/behaviors/flagpole.inc.c:				m->interactObj = NULL;
src/game/behaviors/flagpole.inc.c:				spawn_object(m->marioObj, MODEL_STAR, bhvStar);
src/game/object_helpers.c:    s32 sp0 = o->header.gfx.unk38.curAnim->unk08 - 2;
src/game/object_helpers.c:    u32 spC = (s32) o->header.gfx.unk38.curAnim->flags;
src/game/object_helpers.c:    s32 sp4 = o->header.gfx.unk38.curAnim->unk08 - 2;
src/game/object_helpers.c:    s32 sp0 = o->header.gfx.unk38.curAnim->unk08 - 1;
src/game/object_helpers.c:    s32 sp8 = o->header.gfx.unk38.curAnim->unk08;
src/game/mario_actions_airborne.c:    s32 animFrame = m->marioObj->header.gfx.unk38.animFrame;
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    u32 action = m->action;
src/game/mario_actions_airborne.c:        && !(m->flags & MARIO_UNKNOWN_18)) {
src/game/mario_actions_airborne.c:        if (m->peakHeight - m->pos[1] > 1150.0f) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_MARIO_WAAAOOOW, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->flags |= MARIO_UNKNOWN_18;
src/game/mario_actions_airborne.c:    if (m->actionArg == 0 && (m->forwardVel <= -28.0f || m->forwardVel >= 28.0f)) {
src/game/mario_actions_airborne.c:    m->faceAngle[1] = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_actions_airborne.c:    if (m->forwardVel < 24.0f) {
src/game/mario_actions_airborne.c:        m->forwardVel = 24.0f;
src/game/mario_actions_airborne.c:    if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_airborne.c:        m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/mario_actions_airborne.c:    play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    fallHeight = m->peakHeight - m->pos[1];
src/game/mario_actions_airborne.c:    if (m->actionState == ACT_GROUND_POUND) {
src/game/mario_actions_airborne.c:    if (m->action != ACT_TWIRLING && m->floor->type != SURFACE_BURNING) {
src/game/mario_actions_airborne.c:        if (m->vel[1] < -55.0f) {
src/game/mario_actions_airborne.c:                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 16 : 24;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 8 : 12;
src/game/mario_actions_airborne.c:                m->squishTimer = 30;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_ATTACKED, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:        return set_mario_action(m, m->forwardVel > 28.0f ? ACT_DIVE : ACT_JUMP_KICK, 0);
src/game/mario_actions_airborne.c:    u32 terrainType = m->area->terrainType & TERRAIN_MASK;
src/game/mario_actions_airborne.c:    struct Surface *floor = m->floor;
src/game/mario_actions_airborne.c:        if (!(flags & 0x01) && m->peakHeight - m->pos[1] > 1000.0f && floor->normal.y >= 0.8660254f) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:    floor = m->floor;
src/game/mario_actions_airborne.c:        m->slideVelX += 1.2f * sins(pushAngle);
src/game/mario_actions_airborne.c:        m->slideVelZ += 1.2f * coss(pushAngle);
src/game/mario_actions_airborne.c:        speed = sqrtf(m->slideVelX * m->slideVelX + m->slideVelZ * m->slideVelZ);
src/game/mario_actions_airborne.c:            m->slideVelX = m->slideVelX * 48.0f / speed;
src/game/mario_actions_airborne.c:            m->slideVelZ = m->slideVelZ * 48.0f / speed;
src/game/mario_actions_airborne.c:        m->vel[0] = m->slideVelX;
src/game/mario_actions_airborne.c:        m->vel[2] = m->slideVelZ;
src/game/mario_actions_airborne.c:        m->slideYaw = atan2s(m->slideVelZ, m->slideVelX);
src/game/mario_actions_airborne.c:        m->forwardVel = speed * coss(m->faceAngle[1] - m->slideYaw);
src/game/mario_actions_airborne.c:        play_sound(SOUND_ENV_WIND2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        dragThreshold = m->action == ACT_LONG_JUMP ? 48.0f : 32.0f;
src/game/mario_actions_airborne.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
src/game/mario_actions_airborne.c:        if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_airborne.c:            intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:            intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:            m->forwardVel += 1.5f * coss(intendedDYaw) * intendedMag;
src/game/mario_actions_airborne.c:            m->faceAngle[1] += 512.0f * sins(intendedDYaw) * intendedMag;
src/game/mario_actions_airborne.c:        if (m->forwardVel > dragThreshold) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 1.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel < -16.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel += 2.0f;
src/game/mario_actions_airborne.c:        m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        dragThreshold = m->action == ACT_LONG_JUMP ? 48.0f : 32.0f;
src/game/mario_actions_airborne.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
src/game/mario_actions_airborne.c:        if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_airborne.c:            intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:            intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:            m->forwardVel += intendedMag * coss(intendedDYaw) * 1.5f;
src/game/mario_actions_airborne.c:        if (m->forwardVel > dragThreshold) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 1.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel < -16.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel += 2.0f;
src/game/mario_actions_airborne.c:        m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:        m->slideVelX += sidewaysSpeed * sins(m->faceAngle[1] + 0x4000);
src/game/mario_actions_airborne.c:        m->slideVelZ += sidewaysSpeed * coss(m->faceAngle[1] + 0x4000);
src/game/mario_actions_airborne.c:        m->vel[0] = m->slideVelX;
src/game/mario_actions_airborne.c:        m->vel[2] = m->slideVelZ;
src/game/mario_actions_airborne.c:    if (m->input & INPUT_NONZERO_ANALOG) {
src/game/mario_actions_airborne.c:        intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:        intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:        m->forwardVel += coss(intendedDYaw) * intendedMag;
src/game/mario_actions_airborne.c:        m->faceAngle[1] += sins(intendedDYaw) * intendedMag * 1024.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel < 0.0f) {
src/game/mario_actions_airborne.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:            m->forwardVel *= -1.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel > 32.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 2.0f;
src/game/mario_actions_airborne.c:    m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    s16 targetYawVel = -(s16)(m->controller->stickX * (m->forwardVel / 4.0f));
src/game/mario_actions_airborne.c:        if (m->angleVel[1] < 0) {
src/game/mario_actions_airborne.c:            m->angleVel[1] += 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[1] > 0x10) {
src/game/mario_actions_airborne.c:                m->angleVel[1] = 0x10;
src/game/mario_actions_airborne.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x10, 0x20);
src/game/mario_actions_airborne.c:        if (m->angleVel[1] > 0) {
src/game/mario_actions_airborne.c:            m->angleVel[1] -= 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[1] < -0x10) {
src/game/mario_actions_airborne.c:                m->angleVel[1] = -0x10;
src/game/mario_actions_airborne.c:            m->angleVel[1] = approach_s32(m->angleVel[1], targetYawVel, 0x20, 0x10);
src/game/mario_actions_airborne.c:        m->angleVel[1] = approach_s32(m->angleVel[1], 0, 0x40, 0x40);
src/game/mario_actions_airborne.c:    m->faceAngle[1] += m->angleVel[1];
src/game/mario_actions_airborne.c:    m->faceAngle[2] = 20 * -m->angleVel[1];
src/game/mario_actions_airborne.c:    s16 targetPitchVel = -(s16)(m->controller->stickY * (m->forwardVel / 5.0f));
src/game/mario_actions_airborne.c:        if (m->angleVel[0] < 0) {
src/game/mario_actions_airborne.c:            m->angleVel[0] += 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[0] > 0x20) {
src/game/mario_actions_airborne.c:                m->angleVel[0] = 0x20;
src/game/mario_actions_airborne.c:            m->angleVel[0] = approach_s32(m->angleVel[0], targetPitchVel, 0x20, 0x40);
src/game/mario_actions_airborne.c:        if (m->angleVel[0] > 0) {
src/game/mario_actions_airborne.c:            m->angleVel[0] -= 0x40;
src/game/mario_actions_airborne.c:            if (m->angleVel[0] < -0x20) {
src/game/mario_actions_airborne.c:                m->angleVel[0] = -0x20;
src/game/mario_actions_airborne.c:            m->angleVel[0] = approach_s32(m->angleVel[0], targetPitchVel, 0x40, 0x20);
src/game/mario_actions_airborne.c:        m->angleVel[0] = approach_s32(m->angleVel[0], 0, 0x40, 0x40);
src/game/mario_actions_airborne.c:    m->forwardVel -= 2.0f * ((f32) m->faceAngle[0] / 0x4000) + 0.1f;
src/game/mario_actions_airborne.c:    m->forwardVel -= 0.5f * (1.0f - coss(m->angleVel[1]));
src/game/mario_actions_airborne.c:    if (m->forwardVel < 0.0f) {
src/game/mario_actions_airborne.c:        m->forwardVel = 0.0f;
src/game/mario_actions_airborne.c:    if (m->forwardVel > 16.0f) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] += (m->forwardVel - 32.0f) * 6.0f;
src/game/mario_actions_airborne.c:    } else if (m->forwardVel > 4.0f) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] += (m->forwardVel - 32.0f) * 10.0f;
src/game/mario_actions_airborne.c:        m->faceAngle[0] -= 0x400;
src/game/mario_actions_airborne.c:    m->faceAngle[0] += m->angleVel[0];
src/game/mario_actions_airborne.c:    if (m->faceAngle[0] > 0x2AAA) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] = 0x2AAA;
src/game/mario_actions_airborne.c:    if (m->faceAngle[0] < -0x2AAA) {
src/game/mario_actions_airborne.c:        m->faceAngle[0] = -0x2AAA;
src/game/mario_actions_airborne.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    m->vel[1] = m->forwardVel * sins(m->faceAngle[0]);
src/game/mario_actions_airborne.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_actions_airborne.c:    m->slideVelX = m->vel[0];
src/game/mario_actions_airborne.c:    m->slideVelZ = m->vel[2];
src/game/mario_actions_airborne.c:            if (m->forwardVel > 16.0f) {
src/game/mario_actions_airborne.c:                m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:                if (m->wall != NULL) {
src/game/mario_actions_airborne.c:                    if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                        m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:                    if (m->forwardVel >= 38.0f) {
src/game/mario_actions_airborne.c:                        m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:                        if (m->forwardVel > 8.0f) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    s32 animation = (m->vel[1] >= 0.0f)
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->action == ACT_TRIPLE_JUMP_LAND) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->action == ACT_BACKFLIP_LAND) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    switch (m->actionArg) {
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if ((m->input & INPUT_B_PRESSED) && !(m->heldObj->oInteractionSubtype & INT_SUBTYPE_HOLDABLE_NPC)) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->actionArg == 0) {
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if ((m->input & INPUT_B_PRESSED) && !(m->heldObj->oInteractionSubtype & INT_SUBTYPE_HOLDABLE_NPC)) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:        m->marioObj->header.gfx.angle[1] += 0x8000;
src/game/mario_actions_airborne.c:    if (m->marioObj->header.gfx.unk38.animFrame == 6) play_sound(SOUND_ACTION_SIDE_FLIP_UNK, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (!m->marioObj->oMarioLongJumpIsSlow) {
src/game/mario_actions_airborne.c:    if (m->floor->type == SURFACE_VERTICAL_WIND && m->actionState == 0) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_MARIO_HERE_WE_GO, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:    if (m->action == ACT_LONG_JUMP_LAND) {
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.pos[1] += 42.0f;
src/game/mario_actions_airborne.c:    s16 startTwirlYaw = m->twirlYaw;
src/game/mario_actions_airborne.c:    if (m->input & INPUT_A_DOWN) {
src/game/mario_actions_airborne.c:    m->angleVel[1] = approach_s32(m->angleVel[1], yawVelTarget, 0x200, 0x200);
src/game/mario_actions_airborne.c:    m->twirlYaw += m->angleVel[1];
src/game/mario_actions_airborne.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_START_TWIRL : MARIO_ANIM_TWIRL);
src/game/mario_actions_airborne.c:        m->actionArg = 1;
src/game/mario_actions_airborne.c:    if (startTwirlYaw > m->twirlYaw) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_TWIRL, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[1] += m->twirlYaw;
src/game/mario_actions_airborne.c:    if (m->actionArg == 0) {
src/game/mario_actions_airborne.c:        m->marioBodyState->grabPos = GRAB_POS_LIGHT_OBJ;
src/game/mario_actions_airborne.c:        if (m->action != ACT_DIVE) {
src/game/mario_actions_airborne.c:            if (m->vel[1] < 0.0f && m->faceAngle[0] > -0x2AAA) {
src/game/mario_actions_airborne.c:                m->faceAngle[0] -= 0x200;
src/game/mario_actions_airborne.c:                if (m->faceAngle[0] < -0x2AAA) {
src/game/mario_actions_airborne.c:                    m->faceAngle[0] = -0x2AAA;
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:            if (should_get_stuck_in_ground(m) && m->faceAngle[0] == -0x2AAA) {
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:                if (m->heldObj == NULL) {
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) == 4) {
src/game/mario_actions_airborne.c:                m->action = ACT_AIR_THROW_LAND;
src/game/mario_actions_airborne.c:    if (m->forwardVel < 15.0f) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if (m->forwardVel < 15.0f) {
src/game/mario_actions_airborne.c:            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, 0.98f * m->forwardVel);
src/game/mario_actions_airborne.c:                m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:                set_mario_action(m, m->forwardVel < 0.0f ? ACT_BEGIN_SLIDING : ACT_JUMP_LAND, 0);
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[1] = m->marioObj->oMarioSteepJumpYaw;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->actionTimer < 10) {
src/game/mario_actions_airborne.c:            yOffset = 20 - 2 * m->actionTimer;
src/game/mario_actions_airborne.c:            if (m->pos[1] + yOffset + 160.0f < m->ceilHeight) {
src/game/mario_actions_airborne.c:                m->pos[1] += yOffset;
src/game/mario_actions_airborne.c:                m->peakHeight = m->pos[1];
src/game/mario_actions_airborne.c:                vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_actions_airborne.c:        m->vel[1] = -50.0f;
src/game/mario_actions_airborne.c:        set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_START_GROUND_POUND
src/game/mario_actions_airborne.c:        if (m->actionTimer == 0) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        m->actionTimer++;
src/game/mario_actions_airborne.c:        if (m->actionTimer >= m->marioObj->header.gfx.unk38.curAnim->unk08 + 4) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_MARIO_GROUND_POUND_WAH, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_OOOF2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:                    m->particleFlags |= PARTICLE_MIST_CIRCLE | PARTICLE_HORIZONTAL_STAR;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    play_mario_sound(m, SOUND_ACTION_TERRAIN_JUMP, m->actionArg == 0 ? 0 : -1);
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:    set_mario_animation(m, m->actionArg == 0 ? MARIO_ANIM_SINGLE_JUMP : MARIO_ANIM_FIRE_LAVA_BURN);
src/game/mario_actions_airborne.c:    m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_airborne.c:    play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    m->marioObj->oMarioBurnTimer += 3;
src/game/mario_actions_airborne.c:    m->health -= 10;
src/game/mario_actions_airborne.c:    if (m->health < 0x100) {
src/game/mario_actions_airborne.c:        m->health = 0xFF;
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:    m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_airborne.c:    m->marioObj->oMarioBurnTimer += 3;
src/game/mario_actions_airborne.c:    m->health -= 10;
src/game/mario_actions_airborne.c:    if (m->health < 0x100) {
src/game/mario_actions_airborne.c:        m->health = 0xFF;
src/game/mario_actions_airborne.c:    if (m->actionTimer == 0) {
src/game/mario_actions_airborne.c:        switch (m->actionArg) {
src/game/mario_actions_airborne.c:                m->vel[1] = 45.0f;
src/game/mario_actions_airborne.c:                m->vel[1] = 60.0f;
src/game/mario_actions_airborne.c:                m->vel[1] = 100.0f;
src/game/mario_actions_airborne.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:        if (m->forwardVel < minSpeed) {
src/game/mario_actions_airborne.c:        m->actionTimer = 1;
src/game/mario_actions_airborne.c:            if (m->actionArg < 2) {
src/game/mario_actions_airborne.c:                set_mario_action(m, ACT_CRAZY_BOX_BOUNCE, m->actionArg + 1);
src/game/mario_actions_airborne.c:                m->heldObj->oInteractStatus = INT_STATUS_STOP_RIDING;
src/game/mario_actions_airborne.c:                m->heldObj = NULL;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_MIST_CIRCLE;
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_airborne.c:            if (m->action == ACT_SOFT_BONK) {
src/game/mario_actions_airborne.c:                if (m->action == ACT_THROWN_FORWARD || m->action == ACT_THROWN_BACKWARD) {
src/game/mario_actions_airborne.c:                    set_mario_action(m, landAction, m->hurtCounter);
src/game/mario_actions_airborne.c:                    set_mario_action(m, landAction, m->actionArg);
src/game/mario_actions_airborne.c:                set_mario_action(m, landAction, m->actionArg);
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:    if ((m->input & INPUT_A_PRESSED) && m->wallKickTimer != 0 && m->prevAction == ACT_AIR_HIT_WALL) {
src/game/mario_actions_airborne.c:        m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:    if (m->actionArg != 0) {
src/game/mario_actions_airborne.c:    common_air_knockback_step(m, landAction, ACT_HARD_BACKWARD_GROUND_KB, 0x0002, m->forwardVel);
src/game/mario_actions_airborne.c:    m->forwardVel *= 0.98f;
src/game/mario_actions_airborne.c:    if (m->actionArg != 0) {
src/game/mario_actions_airborne.c:    if (common_air_knockback_step(m, landAction, ACT_HARD_FORWARD_GROUND_KB, 0x002D, m->forwardVel)
src/game/mario_actions_airborne.c:        pitch = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_airborne.c:        m->marioObj->header.gfx.angle[0] = pitch + 0x1800;
src/game/mario_actions_airborne.c:    m->forwardVel *= 0.98f;
src/game/mario_actions_airborne.c:    common_air_knockback_step(m, ACT_FREEFALL_LAND, ACT_HARD_BACKWARD_GROUND_KB, 0x0056, m->forwardVel);
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->forwardVel > -60.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel -= 6.0f;
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:        if (m->forwardVel < -16.0f) {
src/game/mario_actions_airborne.c:            m->forwardVel += 0.8f;
src/game/mario_actions_airborne.c:        if (m->vel[1] < 0.0f && m->unkC4 < 4.0f) {
src/game/mario_actions_airborne.c:            m->unkC4 += 0.05f;
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) == 20) {
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            mario_set_forward_vel(m, -m->forwardVel);
src/game/mario_actions_airborne.c:    if (m->heldObj != NULL) {
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) <= 2) {
src/game/mario_actions_airborne.c:        if (m->input & INPUT_A_PRESSED) {
src/game/mario_actions_airborne.c:            m->vel[1] = 52.0f;
src/game/mario_actions_airborne.c:            m->faceAngle[1] += 0x8000;
src/game/mario_actions_airborne.c:    } else if (m->forwardVel >= 38.0f) {
src/game/mario_actions_airborne.c:        m->wallKickTimer = 5;
src/game/mario_actions_airborne.c:        if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:            m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:        m->wallKickTimer = 5;
src/game/mario_actions_airborne.c:        if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:            m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:        if (m->forwardVel > 8.0f) {
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        m->vel[1] = 30.0f;
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->actionState == 1) {
src/game/mario_actions_airborne.c:                    play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->actionState == 1 && is_anim_past_end(m)) {
src/game/mario_actions_airborne.c:        m->actionState = 2;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        m->vel[1] = 30.0f;
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->actionState == 1) {
src/game/mario_actions_airborne.c:                    play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->actionState == 1 && m->marioObj->header.gfx.unk38.animFrame == 2) {
src/game/mario_actions_airborne.c:        m->actionState = 2;
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) > 30 && m->pos[1] - m->floorHeight > 500.0f) {
src/game/mario_actions_airborne.c:            if (m->actionState == 0 && m->vel[1] < 0.0f && m->floor->normal.y >= 0.9848077f) {
src/game/mario_actions_airborne.c:                m->vel[1] = -m->vel[1] / 2.0f;
src/game/mario_actions_airborne.c:                m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (m->marioObj->oInteractStatus & INT_STATUS_MARIO_DROP_OBJECT) {
src/game/mario_actions_airborne.c:    if (++m->actionTimer > 30 && m->pos[1] - m->floorHeight > 500.0f) {
src/game/mario_actions_airborne.c:            if (m->actionState == 0 && m->vel[1] < 0.0f && m->floor->normal.y >= 0.9848077f) {
src/game/mario_actions_airborne.c:                m->vel[1] = -m->vel[1] / 2.0f;
src/game/mario_actions_airborne.c:                m->actionState = 1;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (!(m->flags & MARIO_MARIO_SOUND_PLAYED)) {
src/game/mario_actions_airborne.c:    if (!(m->input & INPUT_NONZERO_ANALOG)) {
src/game/mario_actions_airborne.c:        m->forwardVel = approach_f32(m->forwardVel, 0.0f, 0.35f, 0.35f);
src/game/mario_actions_airborne.c:            if (m->floor->type == SURFACE_BURNING) {
src/game/mario_actions_airborne.c:                m->actionState = 0;
src/game/mario_actions_airborne.c:                if (!(m->flags & MARIO_METAL_CAP)) {
src/game/mario_actions_airborne.c:                    m->hurtCounter += (m->flags & MARIO_CAP_ON_HEAD) ? 12 : 18;
src/game/mario_actions_airborne.c:                m->vel[1] = 84.0f;
src/game/mario_actions_airborne.c:                play_sound(SOUND_MARIO_ON_FIRE, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                if (m->actionState < 2 && m->vel[1] < 0.0f) {
src/game/mario_actions_airborne.c:                    m->vel[1] = -m->vel[1] * 0.4f;
src/game/mario_actions_airborne.c:                    mario_set_forward_vel(m, m->forwardVel * 0.5f);
src/game/mario_actions_airborne.c:                    m->actionState += 1;
src/game/mario_actions_airborne.c:    if ((m->area->terrainType & TERRAIN_MASK) != TERRAIN_SNOW && !(m->flags & MARIO_METAL_CAP)
src/game/mario_actions_airborne.c:        && m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_FIRE;
src/game/mario_actions_airborne.c:        if (m->actionState == 0) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_MOVING_LAVA_BURN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->health < 0x100) {
src/game/mario_actions_airborne.c:    m->marioBodyState->eyeState = MARIO_EYES_DEAD;
src/game/mario_actions_airborne.c:    if (m->actionState == 0 && m->actionTimer == 0) {
src/game/mario_actions_airborne.c:    if (++(m->actionTimer) > 30 && m->pos[1] - m->floorHeight > 500.0f) {
src/game/mario_actions_airborne.c:            if (m->actionState == 0) {
src/game/mario_actions_airborne.c:                m->marioObj->header.gfx.angle[0] = atan2s(m->forwardVel, -m->vel[1]);
src/game/mario_actions_airborne.c:                if (m->marioObj->header.gfx.angle[0] > 0x1800) {
src/game/mario_actions_airborne.c:                    m->marioObj->header.gfx.angle[0] = 0x1800;
src/game/mario_actions_airborne.c:            if (m->actionState == 0 && m->vel[1] < 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = -m->vel[1] / 2.0f;
src/game/mario_actions_airborne.c:                m->actionState = 1;
src/game/mario_actions_airborne.c:                m->actionTimer = 0;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        m->marioObj->header.gfx.unk38.animID = -1;
src/game/mario_actions_airborne.c:        m->actionState = 1;
src/game/mario_actions_airborne.c:    animFrame = m->marioObj->header.gfx.unk38.animFrame;
src/game/mario_actions_airborne.c:        m->marioBodyState->punchState = (2 << 6) | 6;
src/game/mario_actions_airborne.c:        m->flags |= MARIO_KICKING;
src/game/mario_actions_airborne.c:    if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:        m->statusForCamera->cameraEvent = CAM_EVENT_SHOT_FROM_CANNON;
src/game/mario_actions_airborne.c:    mario_set_forward_vel(m, m->forwardVel);
src/game/mario_actions_airborne.c:            m->faceAngle[0] = atan2s(m->forwardVel, m->vel[1]);
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:            if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:            m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if ((m->flags & MARIO_WING_CAP) && m->vel[1] < 0.0f) {
src/game/mario_actions_airborne.c:    if ((m->forwardVel -= 0.05) < 10.0f) {
src/game/mario_actions_airborne.c:    if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_airborne.c:    s16 startPitch = m->faceAngle[0];
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if (!(m->flags & MARIO_WING_CAP)) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->actionArg == 0) {
src/game/mario_actions_airborne.c:            if (m->marioObj->header.gfx.unk38.animFrame == 1) {
src/game/mario_actions_airborne.c:                play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            if (m->actionArg == 2) {
src/game/mario_actions_airborne.c:                m->actionArg = 1;
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:            m->marioObj->header.gfx.angle[2] = m->faceAngle[2];
src/game/mario_actions_airborne.c:            m->actionTimer = 0;
src/game/mario_actions_airborne.c:            m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:            if (m->wall != NULL) {
src/game/mario_actions_airborne.c:                m->faceAngle[0] = 0;
src/game/mario_actions_airborne.c:                if (m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:                    m->vel[1] = 0.0f;
src/game/mario_actions_airborne.c:                play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK
src/game/mario_actions_airborne.c:                           m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                m->particleFlags |= PARTICLE_VERTICAL_STAR;
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:                if (m->actionTimer++ == 0) {
src/game/mario_actions_airborne.c:                    play_sound(SOUND_ACTION_HIT, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                if (m->actionTimer == 30) {
src/game/mario_actions_airborne.c:                    m->actionTimer = 0;
src/game/mario_actions_airborne.c:                m->faceAngle[0] -= 0x200;
src/game/mario_actions_airborne.c:                if (m->faceAngle[0] < -0x2AAA) {
src/game/mario_actions_airborne.c:                    m->faceAngle[0] = -0x2AAA;
src/game/mario_actions_airborne.c:                m->marioObj->header.gfx.angle[0] = -m->faceAngle[0];
src/game/mario_actions_airborne.c:                m->marioObj->header.gfx.angle[2] = m->faceAngle[2];
src/game/mario_actions_airborne.c:    if (m->faceAngle[0] > 0x800 && m->forwardVel >= 48.0f) {
src/game/mario_actions_airborne.c:        m->particleFlags |= PARTICLE_DUST;
src/game/mario_actions_airborne.c:    if (startPitch <= 0 && m->faceAngle[0] > 0 && m->forwardVel >= 48.0f) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_FLYING_FAST, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    play_sound(SOUND_MOVING_FLYING, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (!(m->input & INPUT_A_DOWN) || (m->marioObj->oInteractStatus & INT_STATUS_MARIO_UNK7)) {
src/game/mario_actions_airborne.c:        m->usedObj->oInteractStatus = 0;
src/game/mario_actions_airborne.c:        m->usedObj->oHootMarioReleaseTime = gGlobalTimer;
src/game/mario_actions_airborne.c:    m->pos[0] = m->usedObj->oPosX;
src/game/mario_actions_airborne.c:    m->pos[1] = m->usedObj->oPosY - 92.5f;
src/game/mario_actions_airborne.c:    m->pos[2] = m->usedObj->oPosZ;
src/game/mario_actions_airborne.c:    m->faceAngle[1] = 0x4000 - m->usedObj->oMoveAngleYaw;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:    vec3f_set(m->vel, 0.0f, 0.0f, 0.0f);
src/game/mario_actions_airborne.c:    vec3f_set(m->marioObj->header.gfx.pos, m->pos[0], m->pos[1], m->pos[2]);
src/game/mario_actions_airborne.c:    vec3s_set(m->marioObj->header.gfx.angle, 0, 0x4000 - m->faceAngle[1], 0);
src/game/mario_actions_airborne.c:    if (m->input & (INPUT_B_PRESSED | INPUT_Z_PRESSED)) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:        if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->marioObj->header.gfx.unk38.animFrame == 7) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:    if (m->actionState == 1 && m->marioObj->header.gfx.unk38.animFrame == 1) {
src/game/mario_actions_airborne.c:        play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    if (m->vel[1] < 4.0f) {
src/game/mario_actions_airborne.c:        if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
src/game/mario_actions_airborne.c:                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
src/game/mario_actions_airborne.c:                m->area->camera->mode = CAM_MODE_NEWCAM;
src/game/mario_actions_airborne.c:        if (m->forwardVel < 32.0f) {
src/game/mario_actions_airborne.c:    s16 intendedDYaw = m->intendedYaw - m->faceAngle[1];
src/game/mario_actions_airborne.c:    f32 intendedMag = m->intendedMag / 32.0f;
src/game/mario_actions_airborne.c:    if (m->actionState == 0) {
src/game/mario_actions_airborne.c:        if (m->marioObj->header.gfx.unk38.animFrame == 1) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:            m->actionState = 1;
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[0] = (s16)(6144.0f * intendedMag * coss(intendedDYaw));
src/game/mario_actions_airborne.c:    m->marioObj->header.gfx.angle[2] = (s16)(-4096.0f * intendedMag * sins(intendedDYaw));
src/game/mario_actions_airborne.c:    if (m->input & INPUT_B_PRESSED) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_Z_PRESSED) {
src/game/mario_actions_airborne.c:            if (m->actionState++ == 0) {
src/game/mario_actions_airborne.c:                m->vel[1] = 42.0f;
src/game/mario_actions_airborne.c:    if (m->actionState == 0 || m->vel[1] > 0.0f) {
src/game/mario_actions_airborne.c:            play_sound(SOUND_ACTION_SPIN, m->marioObj->header.gfx.cameraToObject);
src/game/mario_actions_airborne.c:    m->particleFlags |= PARTICLE_SPARKLES;
src/game/mario_actions_airborne.c:    if (m->pos[1] < m->waterLevel - 100) {
src/game/mario_actions_airborne.c:    if (m->input & INPUT_SQUISHED) {
src/game/mario_actions_airborne.c:    if (m->floor->type == SURFACE_VERTICAL_WIND && (m->action & ACT_FLAG_ALLOW_VERTICAL_WIND_ACTION)) {
src/game/mario_actions_airborne.c:    m->quicksandDepth = 0.0f;
src/game/mario_actions_airborne.c:    switch (m->action) {
src/game/mario_step.c:    if (m->wall != NULL) {
src/game/mario_step.c:        s16 wallAngle = atan2s(m->wall->normal.z, m->wall->normal.x);
src/game/mario_step.c:        m->faceAngle[1] = wallAngle - (s16)(m->faceAngle[1] - wallAngle);
src/game/mario_step.c:        play_sound((m->flags & MARIO_METAL_CAP) ? SOUND_ACTION_METAL_BONK : SOUND_ACTION_BONK,
src/game/mario_step.c:                   m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:        play_sound(SOUND_ACTION_HIT, m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:        mario_set_forward_vel(m, -m->forwardVel);
src/game/mario_step.c:        m->faceAngle[1] += 0x8000;
src/game/mario_step.c:    if (m->action & ACT_FLAG_RIDING_SHELL) {
src/game/mario_step.c:        m->quicksandDepth = 0.0f;
src/game/mario_step.c:        if (m->quicksandDepth < 1.1f) {
src/game/mario_step.c:            m->quicksandDepth = 1.1f;
src/game/mario_step.c:        switch (m->floor->type) {
src/game/mario_step.c:                if ((m->quicksandDepth += sinkingSpeed) >= 10.0f) {
src/game/mario_step.c:                    m->quicksandDepth = 10.0f;
src/game/mario_step.c:                if ((m->quicksandDepth += sinkingSpeed) >= 25.0f) {
src/game/mario_step.c:                    m->quicksandDepth = 25.0f;
src/game/mario_step.c:                if ((m->quicksandDepth += sinkingSpeed) >= 60.0f) {
src/game/mario_step.c:                    m->quicksandDepth = 60.0f;
src/game/mario_step.c:                if ((m->quicksandDepth += sinkingSpeed) >= 160.0f) {
src/game/mario_step.c:                m->quicksandDepth = 0.0f;
src/game/mario_step.c:    s16 floorDYaw = m->floorAngle - m->faceAngle[1];
src/game/mario_step.c:        m->forwardVel = 16.0f;
src/game/mario_step.c:        m->faceAngle[1] = m->floorAngle;
src/game/mario_step.c:        m->forwardVel = -16.0f;
src/game/mario_step.c:        m->faceAngle[1] = m->floorAngle + 0x8000;
src/game/mario_step.c:    struct Surface *floor = m->floor;
src/game/mario_step.c:        m->vel[0] += pushSpeed * sins(pushAngle);
src/game/mario_step.c:        m->vel[2] += pushSpeed * coss(pushAngle);
src/game/mario_step.c:    struct Surface *floor = m->floor;
src/game/mario_step.c:        if (m->action & ACT_FLAG_MOVING) {
src/game/mario_step.c:            s16 pushDYaw = m->faceAngle[1] - pushAngle;
src/game/mario_step.c:            pushSpeed = m->forwardVel > 0.0f ? -m->forwardVel * 0.5f : -8.0f;
src/game/mario_step.c:        m->vel[0] += pushSpeed * sins(pushAngle);
src/game/mario_step.c:        m->vel[2] += pushSpeed * coss(pushAngle);
src/game/mario_step.c:        play_sound(SOUND_ENV_WIND2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:    struct Object *marioObj = m->marioObj;
src/game/mario_step.c:    m->vel[1] = 0.0f;
src/game/mario_step.c:    m->pos[1] = m->floorHeight;
src/game/mario_step.c:    vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:    vec3s_set(marioObj->header.gfx.angle, m->faceAngle[0], m->faceAngle[1], 0);
src/game/mario_step.c:    struct Object *marioObj = m->marioObj;
src/game/mario_step.c:        m->pos[1] = m->floorHeight;
src/game/mario_step.c:        vec3f_copy(marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:        vec3s_set(marioObj->header.gfx.angle, m->faceAngle[0], m->faceAngle[1], 0);
src/game/mario_step.c:    m->wall = upperWall;
src/game/mario_step.c:    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel) {
src/game/mario_step.c:        vec3f_copy(m->pos, nextPos);
src/game/mario_step.c:        m->floor = floor;
src/game/mario_step.c:        m->floorHeight = floorHeight;
src/game/mario_step.c:    vec3f_set(m->pos, nextPos[0], floorHeight, nextPos[2]);
src/game/mario_step.c:    m->floor = floor;
src/game/mario_step.c:    m->floorHeight = floorHeight;
src/game/mario_step.c:        s16 wallDYaw = atan2s(upperWall->normal.z, upperWall->normal.x) - m->faceAngle[1];
src/game/mario_step.c:        intendedPos[0] = m->pos[0] + m->floor->normal.y * (m->vel[0] / 4.0f);
src/game/mario_step.c:        intendedPos[2] = m->pos[2] + m->floor->normal.y * (m->vel[2] / 4.0f);
src/game/mario_step.c:        intendedPos[1] = m->pos[1];
src/game/mario_step.c:    m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
src/game/mario_step.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:    vec3s_set(m->marioObj->header.gfx.angle, m->faceAngle[0], m->faceAngle[1], 0);
src/game/mario_step.c:    if (m->vel[1] > 0) {
src/game/mario_step.c:    if (displacementX * m->vel[0] + displacementZ * m->vel[2] > 0.0f) {
src/game/mario_step.c:    vec3f_copy(m->pos, ledgePos);
src/game/mario_step.c:    m->floor = ledgeFloor;
src/game/mario_step.c:    m->floorHeight = ledgePos[1];
src/game/mario_step.c:    m->floorAngle = atan2s(ledgeFloor->normal.z, ledgeFloor->normal.x);
src/game/mario_step.c:    m->faceAngle[0] = 0;
src/game/mario_step.c:    m->faceAngle[1] = atan2s(wall->normal.z, wall->normal.x) + 0x8000;
src/game/mario_step.c:    m->wall = NULL;
src/game/mario_step.c:        if (nextPos[1] <= m->floorHeight) {
src/game/mario_step.c:            m->pos[1] = m->floorHeight;
src/game/mario_step.c:        m->pos[1] = nextPos[1];
src/game/mario_step.c:    if ((m->action & ACT_FLAG_RIDING_SHELL) && floorHeight < waterLevel) {
src/game/mario_step.c:            m->pos[0] = nextPos[0];
src/game/mario_step.c:            m->pos[2] = nextPos[2];
src/game/mario_step.c:            m->floor = floor;
src/game/mario_step.c:            m->floorHeight = floorHeight;
src/game/mario_step.c:        m->pos[1] = floorHeight;
src/game/mario_step.c:        if (m->vel[1] >= 0.0f) {
src/game/mario_step.c:            m->vel[1] = 0.0f;
src/game/mario_step.c:            if ((stepArg & AIR_STEP_CHECK_HANG) && m->ceil != NULL
src/game/mario_step.c:                && m->ceil->type == SURFACE_HANGABLE) {
src/game/mario_step.c:        if (nextPos[1] <= m->floorHeight) {
src/game/mario_step.c:            m->pos[1] = m->floorHeight;
src/game/mario_step.c:        m->pos[1] = nextPos[1];
src/game/mario_step.c:        vec3f_copy(m->pos, nextPos);
src/game/mario_step.c:        m->floor = floor;
src/game/mario_step.c:        m->floorHeight = floorHeight;
src/game/mario_step.c:    vec3f_copy(m->pos, nextPos);
src/game/mario_step.c:    m->floor = floor;
src/game/mario_step.c:    m->floorHeight = floorHeight;
src/game/mario_step.c:        m->wall = upperWall != NULL ? upperWall : lowerWall;
src/game/mario_step.c:        wallDYaw = atan2s(m->wall->normal.z, m->wall->normal.x) - m->faceAngle[1];
src/game/mario_step.c:        if (m->wall->type == SURFACE_BURNING) {
src/game/mario_step.c:            m->flags |= MARIO_UNKNOWN_30;
src/game/mario_step.c:    if (m->angleVel[1] > 1024) {
src/game/mario_step.c:        heaviness = 1024.0f / m->angleVel[1];
src/game/mario_step.c:    m->vel[1] -= 4.0f * heaviness;
src/game/mario_step.c:    if (m->vel[1] < terminalVelocity) {
src/game/mario_step.c:        m->vel[1] = terminalVelocity;
src/game/mario_step.c:    if (!(m->flags & MARIO_UNKNOWN_08)) {
src/game/mario_step.c:    if (m->action & (ACT_FLAG_INTANGIBLE | ACT_FLAG_INVULNERABLE)) {
src/game/mario_step.c:    if (!(m->input & INPUT_A_DOWN) && m->vel[1] > 20.0f) {
src/game/mario_step.c:        return (m->action & ACT_FLAG_CONTROL_JUMP_HEIGHT) != 0;
src/game/mario_step.c:    if (m->action == ACT_TWIRLING && m->vel[1] < 0.0f) {
src/game/mario_step.c:    } else if (m->action == ACT_SHOT_FROM_CANNON) {
src/game/mario_step.c:        m->vel[1] -= (gravConstant) * 1.0f;
src/game/mario_step.c:    } else if (m->action == ACT_LONG_JUMP || m->action == ACT_SLIDE_KICK
src/game/mario_step.c:               || m->action == ACT_BBH_ENTER_SPIN) {
src/game/mario_step.c:        m->vel[1] -= (gravConstant) * 2.0f;
src/game/mario_step.c:    } else if (m->action == ACT_LAVA_BOOST || m->action == ACT_FALL_AFTER_STAR_GRAB) {
src/game/mario_step.c:        m->vel[1] -= (gravConstant) * 3.2f;
src/game/mario_step.c:    } else if (m->action == ACT_GETTING_BLOWN) {
src/game/mario_step.c:        m->vel[1] -= (gravConstant) * m->unkC4;
src/game/mario_step.c:        m->vel[1] /= 4.0f;
src/game/mario_step.c:        m->vel[1] -= (gravConstant) * 4.0f;
src/game/mario_step.c:        if (m->vel[1] > 75.0f) {
src/game/mario_step.c:                m->vel[1] = 75.0f;
src/game/mario_step.c:        if (m->vel[1] < -75.0f) {
src/game/mario_step.c:                m->vel[1] = -75.0f;
src/game/mario_step.c:    if (m->action != ACT_GROUND_POUND) {
src/game/mario_step.c:        offsetY = m->pos[1] - -1500.0f;
src/game/mario_step.c:        if (m->floor->type == SURFACE_VERTICAL_WIND && -3000.0f < offsetY && offsetY < 2000.0f) {
src/game/mario_step.c:            if (m->vel[1] < maxVelY) {
src/game/mario_step.c:                if ((m->vel[1] += maxVelY / 8.0f) > maxVelY) {
src/game/mario_step.c:                    m->vel[1] = maxVelY;
src/game/mario_step.c:            play_sound(SOUND_ENV_WIND2, m->marioObj->header.gfx.cameraToObject);
src/game/mario_step.c:    m->wall = NULL;
src/game/mario_step.c:        intendedPos[0] = m->pos[0] + m->vel[0] / 4.0f;
src/game/mario_step.c:        intendedPos[1] = m->pos[1] + m->vel[1] / 4.0f;
src/game/mario_step.c:        intendedPos[2] = m->pos[2] + m->vel[2] / 4.0f;
src/game/mario_step.c:    if (m->vel[1] >= 0.0f) {
src/game/mario_step.c:        m->peakHeight = m->pos[1];
src/game/mario_step.c:    m->terrainSoundAddend = mario_get_terrain_sound_addend(m);
src/game/mario_step.c:    if (m->action != ACT_FLYING) {
src/game/mario_step.c:    vec3f_copy(m->marioObj->header.gfx.pos, m->pos);
src/game/mario_step.c:    vec3s_set(m->marioObj->header.gfx.angle, m->faceAngle[0], m->faceAngle[1], 0);
src/game/mario_step.c:    m->vel[0] = m->forwardVel * coss(m->faceAngle[0]) * sins(m->faceAngle[1]);
src/game/mario_step.c:    m->vel[1] = m->forwardVel * sins(m->faceAngle[0]);
src/game/mario_step.c:    m->vel[2] = m->forwardVel * coss(m->faceAngle[0]) * coss(m->faceAngle[1]);
src/game/mario_step.c:    m->vel[0] = m->slideVelX = m->forwardVel * sins(m->faceAngle[1]);
src/game/mario_step.c:    m->vel[1] = 0.0f;
src/game/mario_step.c:    m->vel[2] = m->slideVelZ = m->forwardVel * coss(m->faceAngle[1]);
include/macros.h:// asm-process isn't supported outside of IDO, and undefined behavior causes
include/seq_macros.inc:# To regenerate it, run: ./tools/seq_decoder.py --emit-asm-macros >seq_macros.inc
text/us/dialogs.h:#define SCRAM "scram--"
text/us/dialogs.h:to talk to them--they'll\n\
enhancements/record_demo.patch:+// Prints the status on the bottom-left side of the screen in colorful text.
Binary file .git/index matches
.git/hooks/pre-rebase.sample:			if (!exists $not_in_next{$elem->[0]}) {
.git/hooks/pre-rebase.sample:				print STDERR " $elem->[1]\n";
Binary file .git/objects/pack/pack-1b60a8cc0b6e17dce7d586216fb98ce835c0db45.idx matches
Binary file .git/objects/pack/pack-1b60a8cc0b6e17dce7d586216fb98ce835c0db45.pack matches
Binary file .git/objects/2a/8ec8ece2619d3ca4162cc36f75ae2ee85de2ef matches
Binary file .git/objects/37/1ec1525e235bd2dbafae616c9763ad05fdbc76 matches
Binary file .git/objects/db/30839181cab72ef88b0ceb76375a7dc7683c04 matches
Binary file .git/objects/8f/b839cf09b001f8630aa05314ddd96a9b31b8d8 matches
Binary file .git/objects/e1/d2cece5bc75251c677d3eff26a40957fffae99 matches
Binary file .git/objects/05/0e6ba63696ad2920a95f56517ffedc476c8309 matches
Binary file .git/objects/01/1e79be6351645fe35134c037fd7773bb933dc8 matches
Binary file .git/objects/3f/480bb8d52e324d6e0d82dac35ad6d8cded058e matches
Binary file .git/objects/c7/cf5360eb80964805d810aa6a5700f02be9b7a1 matches
Binary file .git/objects/e7/1e6a5f44ed7b8a2bf4142c39c1e80b2753de3d matches
Binary file .git/objects/f1/ac3b1a4803d3f1a30398f184dda4cd91f99ad2 matches
Binary file .git/objects/e5/8f02a67dbed42d931acc8c17dc8b2c48a76dde matches
Doxyfile:# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
Doxyfile:# Filters (see: http://doc.qt.io/qt-4.8/qthelpproject.html#custom-filters).
lib/src/guMtxF2L.c:    s32 *m1 = &m->m[0][0];
lib/src/guMtxF2L.c:    s32 *m2 = &m->m[2][0];
lib/src/guMtxF2L.c:    m1 = (u32 *) &m->m[0][0];
lib/src/guMtxF2L.c:    m2 = (u32 *) &m->m[2][0];
Binary file actors/tree/tree_left_side.rgba16.png matches
Binary file actors/penguin/penguin_eye_half_closed.rgba16.png matches
Binary file actors/penguin/penguin_eye_open.rgba16.png matches
Binary file actors/door/metal_door_overlay.rgba16.png matches
Binary file actors/klepto/klepto_wing_flap.rgba16.png matches
Binary file actors/explosion/explosion_0.rgba16.png matches
Binary file actors/bowser/bowser_claw_horn_angle.rgba16.png matches
puppycam.patch:-                m, (m->flags & MARIO_METAL_CAP) ? (s32)SOUND_ACTION_METAL_JUMP 
puppycam.patch:+                m, (m->flags & MARIO_METAL_CAP) ? (s32)SOUND_ACTION_METAL_JUMP
puppycam.patch:     if (m->intendedMag > 0.0f) {
puppycam.patch:-        m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
puppycam.patch:+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX) + m->area->camera->yaw;
puppycam.patch:+            m->intendedYaw = atan2s(-controller->stickY, controller->stickX)-newcam_yaw+0x4000;
puppycam.patch:         m->input |= INPUT_NONZERO_ANALOG;
puppycam.patch:         m->intendedYaw = m->faceAngle[1];
puppycam.patch:     s32 animFrame = m->marioObj->header.gfx.unk38.animFrame;
puppycam.patch:-    s32 animation = (m->vel[1] >= 0.0f) 
puppycam.patch:+    s32 animation = (m->vel[1] >= 0.0f)
puppycam.patch:             m->faceAngle[0] = 0;
puppycam.patch:-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:             m->particleFlags |= PARTICLE_VERTICAL_STAR;
puppycam.patch:-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:     if (m->input & INPUT_Z_PRESSED) {
puppycam.patch:         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
puppycam.patch:-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:     if (!(m->flags & MARIO_WING_CAP)) {
puppycam.patch:         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
puppycam.patch:-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:     if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
puppycam.patch:-        set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:     if (m->actionState == 0) {
puppycam.patch:             m->faceAngle[0] = 0;
puppycam.patch:-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:                 m->particleFlags |= PARTICLE_VERTICAL_STAR;
puppycam.patch:                 set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:                 if (m->actionTimer++ == 0) {
puppycam.patch:                     play_sound(SOUND_ACTION_HIT, m->marioObj->header.gfx.cameraToObject);
puppycam.patch:     if (m->input & (INPUT_B_PRESSED | INPUT_Z_PRESSED)) {
puppycam.patch:         if (m->area->camera->mode == CAMERA_MODE_BEHIND_MARIO) {
puppycam.patch:-            set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:         if (m->input & INPUT_B_PRESSED) {
puppycam.patch:     if (m->vel[1] < 4.0f) {
puppycam.patch:         if (m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
puppycam.patch:-            set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
puppycam.patch:+                set_camera_mode(m->area->camera, m->area->camera->defMode, 1);
puppycam.patch:+                m->area->camera->mode = CAM_MODE_NEWCAM;
puppycam.patch:         if (m->forwardVel < 32.0f) {
puppycam.patch:-    if (m->actionTimer++ == 10 && m->area->camera->mode != CAMERA_MODE_BEHIND_MARIO) {
puppycam.patch:-        set_camera_mode(m->area->camera, CAMERA_MODE_BEHIND_MARIO, 1);
Binary file levels/castle_inside/33.rgba16.png matches
Binary file levels/castle_inside/21.rgba16.png matches
Binary file levels/ending/cake.png matches
Binary file levels/lll/16.rgba16.png matches
Binary file levels/ssl/4.rgba16.png matches
Binary file levels/jrb/1.rgba16.png matches
Binary file baserom.us.z64 matches
sound/README.md:custom-made samples and sequences it is advisable to include that substring
Binary file sound/samples/sfx_terrain/07_step_sand.aiff matches
Binary file sound/samples/sfx_6/0D.aiff matches
Binary file sound/samples/instruments/0B.aiff matches
Binary file sound/samples/instruments/15.aiff matches
Binary file sound/samples/instruments/36.aiff matches
Binary file sound/samples/instruments/27.aiff matches
Binary file sound/samples/instruments/31.aiff matches
Binary file sound/samples/instruments/03.aiff matches
Binary file sound/samples/instruments/24.aiff matches
Binary file sound/samples/instruments/3E.aiff matches
Binary file sound/samples/instruments/30.aiff matches
Binary file sound/samples/instruments/1B.aiff matches
Binary file sound/samples/instruments/29.aiff matches
Binary file sound/samples/instruments/34.aiff matches
Binary file sound/samples/instruments/16.aiff matches
Binary file sound/samples/bowser_organ/01.aiff matches
Binary file sound/samples/bowser_organ/00.aiff matches
Binary file sound/samples/sfx_4/03.aiff matches
Binary file sound/samples/sfx_4/00.aiff matches
Binary file sound/samples/sfx_mario_peach/04.aiff matches
Binary file sound/samples/sfx_mario_peach/0D.aiff matches
Binary file sound/samples/sfx_mario_peach/00.aiff matches
Binary file sound/samples/sfx_mario/12.aiff matches
Binary file sound/samples/sfx_mario/0D.aiff matches
Binary file sound/samples/sfx_mario/1A.aiff matches
Binary file sound/samples/sfx_mario/08.aiff matches
Binary file sound/samples/sfx_9/01.aiff matches
Binary file sound/samples/sfx_9/06.aiff matches
Binary file sound/samples/sfx_9/00.aiff matches
Binary file sound/samples/sfx_5/0C.aiff matches
Binary file sound/samples/sfx_5/00.aiff matches
Binary file build/us/src/game/camera.o matches
Binary file build/us/sm64.us.z64 matches
Binary file build/us/actors/group9.mio0.o matches
Binary file build/us/actors/group12.mio0.o matches
Binary file build/us/actors/group11.mio0.o matches
Binary file build/us/actors/group13.elf matches
Binary file build/us/actors/group13.mio0.o matches
Binary file build/us/actors/group17.mio0.o matches
Binary file build/us/actors/group12.elf matches
Binary file build/us/actors/water_ring/water_ring.rgba16 matches
Binary file build/us/actors/group12.o matches
Binary file build/us/actors/group13.o matches
Binary file build/us/sm64.us.elf matches
Binary file build/us/levels/castle_grounds/leveldata.mio0.o matches
Binary file build/us/levels/menu/leveldata.mio0.o matches
Binary file build/us/levels/lll/leveldata.mio0.o matches
Binary file build/us/levels/thi/leveldata.mio0.o matches
Binary file build/us/levels/ttm/leveldata.mio0.o matches
Binary file build/us/levels/ddd/leveldata.mio0.o matches
Binary file build/us/levels/wmotr/leveldata.mio0.o matches
Binary file build/us/levels/ccm/leveldata.elf matches
Binary file build/us/sm64.us.bin matches
Binary file build/us/bin/snow.mio0.o matches
Binary file build/us/bin/bbh_skybox.mio0.o matches
Binary file build/us/bin/water_skybox.mio0.o matches
Binary file build/us/bin/ccm_skybox.mio0.o matches
Binary file build/us/bin/bitfs_skybox.mio0.o matches
Binary file build/us/bin/cloud_floor_skybox.mio0.o matches
Binary file build/us/bin/bits_skybox.mio0.o matches
Binary file textures/intro_raw/red_star_4.rgba16.png matches
Binary file textures/water/jrb_textures.00800.rgba16.png matches
Binary file textures/skyboxes/bbh.png matches
Binary file textures/skyboxes/water.png matches
Binary file textures/skyboxes/clouds.png matches
Binary file textures/skyboxes/bidw.png matches
Binary file textures/skyboxes/bits.png matches
Binary file textures/segment2/segment2.05600.rgba16.png matches
Binary file textures/inside/inside_castle_textures.01000.rgba16.png matches
tools/asm_processor/build.py:asm_processor = ['python3', os.path.join(dir_path, "asm-processor.py")]
tools/asm_processor/build.py:subprocess.check_call(asm_processor + opt_flags + [in_file, '--post-process', out_file, '--assembler', assembler_sh, '--asm-prelude', prelude])
tools/asm_processor/asm-processor.py:    o_file = tempfile.NamedTemporaryFile(prefix='asm-processor', suffix='.o', delete=False)
tools/asm_processor/asm-processor.py:    s_file = tempfile.NamedTemporaryFile(prefix='asm-processor', suffix='.s', delete=False)
tools/asm_processor/asm-processor.py:    parser.add_argument('--asm-prelude', dest='asm_prelude', help="path to a file containing a prelude to the assembly file (with .set and .macro directives, e.g.)")
Binary file tools/ido5.3_compiler/usr/lib/libc.so.1 matches
Binary file tools/ido5.3_compiler/usr/lib/as1 matches
Binary file tools/ido5.3_compiler/usr/lib/ugen matches
Binary file tools/ido5.3_compiler/usr/lib/uopt matches
Binary file tools/ido5.3_compiler/usr/lib/uld matches
tools/assemble_sound.py:            "date must have format yyyy-mm-dd",
tools/stb/stb_image.h:// zlib-from-memory implementation for PNG reading
tools/stb/stb_image.h:      // force the image data from big-endian to platform-native.
tools/seq_decoder.py:    print(f"Usage: {sys.argv[0]} (--emit-asm-macros | input.m64)")
tools/seq_decoder.py:if sys.argv[1] == "--emit-asm-macros":
tools/seq_decoder.py:    print("# To regenerate it, run: ./tools/seq_decoder.py --emit-asm-macros >seq_macros.inc")
